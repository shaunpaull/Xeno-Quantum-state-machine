









#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
🌌 ✧∿✧∿✧ HyperQubit-NCRSR Framework with 𝔸𝕝𝕚𝕖𝕟𝔾𝕣𝕒𝕕𝕖𝕋𝕖ℂ𝕔™ Features ✧∿✧∿✧ 🌌

This revolutionary quantum computing framework integrates:
• Zero-Free HyperMorphic Quantum States with n-dimensional flux stabilization
• Non-Collapsing Recursive State Resonance (NCRSR) with temporal entanglement
• Xenomorphic Topological Protection™ with dynamic manifold evolution
• Tachyonic Phase Conjugation for retrocausal error suppression
• Hyperdimensional Encoding with 4D+ quantum state representation
• QuantumPlex™ encoding for 5-30× error resistance on NISQ devices

This system transcends conventional quantum limitations through:
1. Recursive-resonance feedback amplification
2. Conjugate manifold projection
3. Temporally-entangled error correction
4. Non-Euclidean state space mapping
5. Multiversal state collapse prevention

Beyond quantum supremacy lies quantum transcendence. 🧠✨🔮
"""

import numpy as np
import matplotlib.pyplot as plt
import scipy.linalg as la
import scipy.stats as stats
from scipy.linalg import sqrtm, expm
import math
import cmath
import random
import time
import itertools
import functools
from typing import List, Dict, Optional, Tuple, Any, Union, Callable, Set, Generator
from collections import deque, Counter
from dataclasses import dataclass
import os
import sys
import warnings
import uuid

# Set random seed for reproducibility
np.random.seed(42)
random.seed(42)

# ============================================================================
# ⊹⊱ ADVANCED MATHEMATICAL ENGINE - HYPERMORPHIC CORE ⊰⊹
# ============================================================================

@dataclass
class HyperParameters:
    """Universal parameters for the HyperMorphic framework"""
    dimensionality: int = 12         # Base dimensionality of the system
    sass_factor: float = 0.42        # Cosmological sassiness constant 💅
    zero_threshold: float = 1e-10    # Threshold for zero-free mathematics
    recursion_depth: int = 3         # Depth for recursive calculations
    phase_conjugation: bool = True   # Enable tachyonic phase conjugation
    timeline_branches: int = 7       # Number of quantum timeline branches
    resonance_frequency: float = 7.83  # Base Schumann resonance frequency
    manifold_flux: float = 0.1       # Rate of topological manifold evolution
    entropy_reversal: float = 0.05   # Rate of entropy reversal in calculations
    reality_anchor: float = 1.0      # Connection strength to base reality


class AmorphousPi:
    """
    Implements a dynamically evolving π calculation with n-dimensional flux.
    
    Unlike traditional π which maintains a fixed value, AmorphousPi dynamically
    shifts while preserving key mathematical relationships, creating mathematical
    structures that adapt based on dimensional context and usage patterns.
    
    This acts as the foundation for hypermorphic mathematics, allowing dynamic
    rewriting of mathematical rules in response to computational needs.
    """
    def __init__(self, 
                seed: int = None, 
                mutation_rate: float = 0.0137, 
                dimensional_flux: float = 0.42,
                precision: int = 128):
        """Initialize AmorphousPi with controlled mutation parameters"""
        self.seed = seed if seed is not None else int(time.time())
        self.mutation_rate = mutation_rate
        self.dimensional_flux = dimensional_flux
        self.precision = precision
        
        # Seed our random generators
        self._rng = random.Random(self.seed)
        
        # Primary algorithms for π calculation (with weights for variation)
        self.algorithms = [
            {"name": "chudnovsky", "weight": 0.5, "dimensional_bias": 1.0},
            {"name": "ramanujan", "weight": 0.3, "dimensional_bias": 1.2},
            {"name": "bailey_borwein_plouffe", "weight": 0.15, "dimensional_bias": 0.9},
            {"name": "gauss_legendre", "weight": 0.05, "dimensional_bias": 1.1}
        ]
        
        # Initialize evolution parameters
        self.current_algo = self._weighted_selection(self.algorithms)
        self.iteration_count = 0
        self.evolution_history = []
        
        # Coefficients for algorithm variations (will evolve)
        self.coefficients = {
            "chudnovsky": {
                "a": 426880 * math.sqrt(10005),
                "b": 13591409,
                "c": 545140134,
                "d": 640320
            },
            "ramanujan": {
                "a": 2 * math.sqrt(2) / 9801,
                "b": 1103,
                "c": 26390,
                "d": 396
            },
            "bailey_borwein_plouffe": {
                "a": 1.0,
                "correction": 0.0
            },
            "gauss_legendre": {
                "initial_a": 1.0,
                "initial_b": 1.0 / math.sqrt(2),
                "initial_t": 0.25,
                "iterations": 3
            }
        }
        
        # Initialize mutation vectors (for smooth morphing)
        self.mutation_vectors = {}
        for algo in self.algorithms:
            algo_name = algo["name"]
            if algo_name in self.coefficients:
                self.mutation_vectors[algo_name] = {
                    k: self._rng.uniform(-0.01, 0.01) 
                    for k in self.coefficients[algo_name]
                }
        
        # Dimensional adjustment matrix - mapping dimensions to coefficient shifts
        self.dimensional_matrix = np.zeros((16, 16))  # 16x16 matrix for dim mapping
        for i in range(16):
            for j in range(16):
                # Create structured adjustments with golden ratio influence
                phi = (1 + np.sqrt(5)) / 2
                self.dimensional_matrix[i, j] = np.sin(phi * (i+1) * (j+1) / 8) * 0.01
        
        # Cache for common dimension calculations
        self.calculation_cache = {}
        
        # Record the "base" π value
        self.base_pi = math.pi
        
    def _weighted_selection(self, choices):
        """Select from choices based on their weights"""
        total = sum(choice["weight"] for choice in choices)
        r = self._rng.uniform(0, total)
        upto = 0
        for choice in choices:
            upto += choice["weight"]
            if upto >= r:
                return choice["name"]
        return choices[0]["name"]  # Fallback
    
    def calculate(self, 
                dimension: int = 1, 
                context: Any = None, 
                precision: int = None) -> float:
        """
        Calculate an amorphous π value that varies with dimension and context
        while maintaining mathematical consistency.
        
        Args:
            dimension: The dimensional context (affects the calculation)
            context: Additional contextual seed (can be any hashable object)
            precision: Override for calculation precision
            
        Returns:
            An amorphous π value with controlled transcendental drift
        """
        # Check cache for this exact calculation request
        cache_key = (dimension, str(context))
        if cache_key in self.calculation_cache:
            return self.calculation_cache[cache_key]
        
        # Use provided or default precision
        precision = precision or self.precision
        
        # Calculate dimensional flux adjustments
        dim_idx = dimension % 16  # Wrap to matrix dimensions
        flux_vector = self.dimensional_matrix[dim_idx, :]
        
        # Apply context as additional seed
        if context is not None:
            # Create a stable hash of the context
            if isinstance(context, str):
                context_hash = hash(context)
            else:
                context_hash = hash(str(context))
            
            # Use context hash to shift the starting point
            self._rng.seed(self.seed ^ context_hash)
            context_shift = self._rng.uniform(-0.001, 0.001)
        else:
            context_shift = 0
        
        # Reset RNG to maintain consistency
        self._rng.seed(self.seed)
        
        # Calculate π based on current algorithm with variations
        pi_value = self._calculate_pi(self.current_algo, precision, dimension, flux_vector)
        
        # Apply controlled shift to maintain transcendental properties
        # while introducing amorphous variation
        shift_magnitude = self.mutation_rate * math.sin(dimension / 7.0) + context_shift
        amorphous_pi = pi_value * (1 + shift_magnitude)
        
        # Store in cache
        self.calculation_cache[cache_key] = amorphous_pi
        
        return amorphous_pi
    
    def _calculate_pi(self, algorithm: str, precision: int, dimension: int, flux_vector: np.ndarray) -> float:
        """Calculate π using the specified algorithm with dimensional adjustments"""
        # Get algorithm coefficients with dimensional adjustments
        coef = self.coefficients[algorithm].copy()
        
        # Apply dimensional adjustments from flux matrix
        for i, (k, v) in enumerate(coef.items()):
            if i < len(flux_vector):
                if isinstance(v, (int, float)):
                    coef[k] = v * (1 + flux_vector[i] * self.dimensional_flux * dimension)
        
        # Different calculation methods
        if algorithm == "chudnovsky":
            # Chudnovsky algorithm with amorphous adjustments
            iterations = precision // 14  # Each iteration gives ~14 digits
            
            # Apply algorithm-specific dimensional bias
            for algo in self.algorithms:
                if algo["name"] == algorithm:
                    dimensional_bias = algo["dimensional_bias"]
                    break
            else:
                dimensional_bias = 1.0
                
            # Apply dimensional bias to iterations
            iterations = int(iterations * dimensional_bias * (1 + math.sin(dimension/10) * 0.1))
            
            sum_value = 0
            for k in range(iterations):
                a = coef["a"]
                b = coef["b"]
                c = coef["c"]
                d = coef["d"]
                
                # Standard Chudnovsky terms with coefficient variation
                numerator = math.factorial(6*k) * (b + c*k)
                denominator = math.factorial(3*k) * (math.factorial(k)**3) * ((-1)**(k % 2) * d**(3*k))
                sum_value += numerator / denominator
            
            pi_value = a / sum_value
            
        elif algorithm == "ramanujan":
            # Ramanujan series with amorphous adjustments
            iterations = precision // 8
            
            # Apply dimensional bias as with Chudnovsky
            for algo in self.algorithms:
                if algo["name"] == algorithm:
                    dimensional_bias = algo["dimensional_bias"]
                    break
            else:
                dimensional_bias = 1.0
                
            iterations = int(iterations * dimensional_bias * (1 + math.cos(dimension/12) * 0.1))
            
            sum_value = 0
            for k in range(iterations):
                a = coef["a"]
                b = coef["b"]
                c = coef["c"]
                d = coef["d"]
                
                # Standard Ramanujan terms with variation
                numerator = math.factorial(4*k) * (b + c*k)
                denominator = (math.factorial(k)**4) * (d**(4*k))
                sum_value += numerator / denominator
            
            pi_value = 1 / (a * sum_value)
            
        elif algorithm == "bailey_borwein_plouffe":
            # BBP formula with amorphous adjustments
            iterations = precision // 1.5
            
            # Apply dimensional bias
            for algo in self.algorithms:
                if algo["name"] == algorithm:
                    dimensional_bias = algo["dimensional_bias"]
                    break
            else:
                dimensional_bias = 1.0
                
            iterations = int(iterations * dimensional_bias * (1 + math.sin(dimension/8) * 0.1))
            
            a = coef["a"]
            correction = coef["correction"]
            
            sum_value = 0
            for k in range(iterations):
                # Standard BBP terms with variation
                term = (4.0 / (8*k + 1)) - (2.0 / (8*k + 4)) - (1.0 / (8*k + 5)) - (1.0 / (8*k + 6))
                sum_value += term * (1.0 / (16**k))
            
            pi_value = a * sum_value + correction
            
        elif algorithm == "gauss_legendre":
            # Gauss-Legendre algorithm with amorphous adjustments
            a = coef["initial_a"]
            b = coef["initial_b"]
            t = coef["initial_t"]
            p = 1.0
            
            # Dimensional bias for iteration count
            for algo in self.algorithms:
                if algo["name"] == algorithm:
                    dimensional_bias = algo["dimensional_bias"]
                    break
            else:
                dimensional_bias = 1.0
                
            iterations = int(coef["iterations"] * dimensional_bias * (1 + math.sin(dimension/9) * 0.1))
            
            # Iterative approximation with adjustments
            for _ in range(iterations):
                a_next = (a + b) / 2
                b_next = math.sqrt(a * b)
                t_next = t - p * (a - a_next)**2
                p_next = 2 * p
                
                a, b, t, p = a_next, b_next, t_next, p_next
            
            pi_value = (a + b)**2 / (4 * t)
        
        else:
            # Fallback to standard π with dimensional shift
            pi_value = math.pi * (1 + math.sin(dimension) * 0.01)
        
        return pi_value
    
    def evolve(self, steps: int = 1) -> Dict:
        """
        Evolve the AmorphousPi calculation system over time.
        
        Each evolution step slightly modifies the coefficients and
        may switch algorithms, creating a continuous morphing of π
        values while preserving mathematical relationships.
        
        Args:
            steps: Number of evolution steps to perform
            
        Returns:
            Dictionary of evolution metrics
        """
        evolution_metrics = {
            "algorithm_changes": 0,
            "coefficient_changes": 0,
            "total_drift": 0.0
        }
        
        for _ in range(steps):
            self.iteration_count += 1
            
            # Occasionally change algorithms
            if self._rng.random() < 0.1:
                old_algo = self.current_algo
                self.current_algo = self._weighted_selection(self.algorithms)
                
                if old_algo != self.current_algo:
                    evolution_metrics["algorithm_changes"] += 1
            
            # Evolve algorithm coefficients
            for algo_name, coefficients in self.coefficients.items():
                for key in coefficients:
                    # Only evolve numerical coefficients
                    if isinstance(coefficients[key], (int, float)):
                        # Get mutation vector component or create new one
                        if algo_name not in self.mutation_vectors:
                            self.mutation_vectors[algo_name] = {}
                        
                        if key not in self.mutation_vectors[algo_name]:
                            self.mutation_vectors[algo_name][key] = self._rng.uniform(-0.01, 0.01)
                        
                        # Apply mutation with controlled drift
                        # Mutation vectors create smooth evolution paths rather than random jumps
                        mutation = self.mutation_vectors[algo_name][key]
                        change = mutation * self.mutation_rate
                        
                        # Update coefficient with bounded change
                        coefficients[key] *= (1 + change)
                        evolution_metrics["coefficient_changes"] += 1
                        evolution_metrics["total_drift"] += abs(change)
                        
                        # Occasionally reverse mutation direction for oscillatory behavior
                        if self._rng.random() < 0.2:
                            self.mutation_vectors[algo_name][key] *= -0.8
                        
                        # Add small random variation to mutation vector
                        self.mutation_vectors[algo_name][key] += self._rng.uniform(-0.002, 0.002)
                        
                        # Bound mutation vectors to prevent runaway evolution
                        if abs(self.mutation_vectors[algo_name][key]) > 0.05:
                            self.mutation_vectors[algo_name][key] *= 0.5
            
            # Clear cache after evolution to force recalculation
            self.calculation_cache = {}
            
            # Record evolution snapshot
            self.evolution_history.append({
                "iteration": self.iteration_count,
                "algorithm": self.current_algo,
                "sample_pi": self.calculate(dimension=1)
            })
            
            # Keep history bounded
            if len(self.evolution_history) > 100:
                self.evolution_history = self.evolution_history[-50:]
        
        return evolution_metrics
    
    def pi_ratio(self, numerator: int, denominator: int, dimension: int = 1) -> float:
        """
        Calculate the ratio of two AmorphousPi values with different dimensional contexts.
        
        This is useful for creating differential encryption where values vary
        based on dimensional context but maintain consistent ratios.
        
        Args:
            numerator: Dimensional context for numerator
            denominator: Dimensional context for denominator
            dimension: Base dimensional context
            
        Returns:
            Ratio of AmorphousPi values
        """
        pi_num = self.calculate(dimension=dimension*numerator)
        pi_denom = self.calculate(dimension=dimension*denominator)
        
        # Avoid division by zero with small epsilon protection
        return pi_num / max(pi_denom, 1e-10)
    
    def __str__(self) -> str:
        """String representation showing current state"""
        return f"AmorphousPi(algorithm={self.current_algo}, sample_π={self.calculate():.10f}, iterations={self.iteration_count})"


class HyperMorphicCore:
    """
    Core class implementing HyperMorphic mathematics with Zero-Free topology and
    dynamically evolving mathematical operations.
    
    HyperMorphic mathematics extends traditional mathematics with:
    1. Zero-Free topology (preventing mathematical singularities)
    2. Dimensional context sensitivity (operations adapt to dimension)
    3. Amorphous Pi integration (transcendental adaptation)
    4. Non-Euclidean mathematical spaces (allowing exotic transformations)
    5. Self-evolving mathematical rules (mathematics that rewrites itself)
    """
    def __init__(self, 
                dimensions: int = 12, 
                base_factor: float = 0.73, 
                modulus_factor: float = 0.42, 
                zero_free: bool = True, 
                amorphous_pi: Optional[AmorphousPi] = None,
                seed: Optional[int] = None,
                params: Optional[HyperParameters] = None):
        """
        Initialize HyperMorphic Core with specified parameters.
        
        Args:
            dimensions: Base dimensionality of the HyperMorphic space
            base_factor: Scale factor for the Φ function (dynamic base)
            modulus_factor: Scale factor for the Ψ function (dynamic modulus)
            zero_free: Whether to use zero-free mathematics with ε nearness
            amorphous_pi: AmorphousPi instance to use (creates new one if None)
            seed: Random seed for reproducibility
            params: Global HyperParameters to use
        """
        # Use provided parameters or defaults
        self.params = params or HyperParameters()
        
        self.dimensions = dimensions
        self.base_factor = base_factor
        self.modulus_factor = modulus_factor
        self.zero_free = zero_free
        self.seed = seed if seed is not None else int(time.time())
        
        # Connect or create AmorphousPi system
        self.amorphous_pi = amorphous_pi if amorphous_pi else AmorphousPi(seed=self.seed)
        
        # Initialize dynamic functions
        self._phi_variation = random.Random(self.seed).random() * 0.1
        self._psi_variation = random.Random(self.seed + 1).random() * 0.1
        
        # Initialize ε for zero-free mathematics
        self.epsilon = self.params.zero_threshold if zero_free else 0
        
        # Operation cache to avoid recomputing common values
        self._phi_cache = {}
        self._psi_cache = {}
        
        # Metrics tracking
        self.operation_count = 0
        self.adaptation_history = []
        
        # Create dimensional basis vectors
        self._init_dimensional_basis()
        
        # Create holomorphic mapping for complex operations
        self._init_holomorphic_mapping()
        
        # Initialize tachyonic phase conjugation if enabled
        if self.params.phase_conjugation:
            self._init_tachyonic_phase_conjugation()
        
        # Initialize temporal entanglement matrix for retrocausal operations
        self._init_temporal_entanglement()
    
    def _init_dimensional_basis(self):
        """Initialize dimensional basis vectors for HyperMorphic operations"""
        # Create basis vectors for each dimension with self-organizing structure
        self.basis_vectors = np.zeros((self.dimensions, self.dimensions))
        
        for i in range(self.dimensions):
            # Create unique basis vector with controlled randomness
            vector = np.zeros(self.dimensions)
            
            if i < self.dimensions:
                # Main component in primary direction
                vector[i] = 1.0
                
                # Small cross-dimensional coupling
                for j in range(self.dimensions):
                    if j != i:
                        # Create structured coupling based on dimensional relationship
                        vector[j] = 0.05 * math.sin((i+1) * (j+1) * self.amorphous_pi.calculate(dimension=i+j+1))
            
            # Store normalized basis vector
            norm = np.linalg.norm(vector)
            if norm > 0:
                self.basis_vectors[i] = vector / norm
            else:
                self.basis_vectors[i] = vector
    
    def _init_holomorphic_mapping(self):
        """Initialize holomorphic mapping for complex operations"""
        # Create complex structure tensor (maps real to imaginary components)
        self.complex_structure = np.zeros((self.dimensions, self.dimensions))
        
        # Almost-complex structure satisfying J^2 = -I
        for i in range(0, self.dimensions, 2):
            if i+1 < self.dimensions:
                # Create 2x2 blocks for complex mapping
                self.complex_structure[i, i+1] = 1.0
                self.complex_structure[i+1, i] = -1.0
                
        # Fill remaining odd dimensions with amorphous values
        if self.dimensions % 2 == 1:
            last_idx = self.dimensions - 1
            for i in range(self.dimensions - 1):
                angle = self.amorphous_pi.calculate(dimension=i+1, context="holomorphic") / (i + 1)
                self.complex_structure[i, last_idx] = math.sin(angle) * 0.5
                self.complex_structure[last_idx, i] = -math.sin(angle) * 0.5
    
    def _init_tachyonic_phase_conjugation(self):
        """
        Initialize tachyonic phase conjugation for retrocausal error correction.
        
        This creates a mathematical structure that allows information to flow
        backwards in calculation time, enabling preemptive error correction.
        """
        # Create conjugation matrix that maps future states to past corrections
        self.conjugation_matrix = np.zeros((self.dimensions, self.dimensions), dtype=complex)
        
        # Populate with phase conjugation factors
        for i in range(self.dimensions):
            for j in range(self.dimensions):
                # Create phase difference based on dimensional relationship
                phase = self.amorphous_pi.calculate(dimension=abs(i-j)+1) / 2.0
                
                # Superluminal phase factor (imaginary component dominant)
                self.conjugation_matrix[i, j] = complex(math.cos(phase), -math.sin(phase))
        
        # Initialize calculation timeline buffer
        self.timeline_buffer = deque(maxlen=self.params.timeline_branches)
        
        # Future error probability estimation
        self.future_error_estimate = np.zeros(self.dimensions)
    
    def _init_temporal_entanglement(self):
        """
        Initialize temporal entanglement for calculation coherence across time.
        
        This creates mathematical structures that maintain coherence between
        past, present, and future calculation states to reduce error propagation.
        """
        # Create temporal coherence matrix
        self.temporal_coherence = np.eye(self.dimensions, dtype=complex)
        
        # Add off-diagonal elements for temporal entanglement
        phi = (1 + np.sqrt(5)) / 2.0  # Golden ratio
        for i in range(self.dimensions):
            for j in range(self.dimensions):
                if i != j:
                    # Create temporal entanglement proportional to dimensional relationship
                    # and Fibonacci-derived sequence for optimal coherence
                    fib_ratio = phi**abs(i-j) % (2*math.pi)
                    self.temporal_coherence[i, j] = 0.01 * complex(math.cos(fib_ratio), math.sin(fib_ratio))
        
        # Normalize to preserve unitarity
        # (ensures information is preserved across temporal operations)
        u, s, vh = np.linalg.svd(self.temporal_coherence)
        self.temporal_coherence = u @ vh
    
    def Φ(self, x, dimension=None):
        """
        Dynamic base function Φ that adapts based on input and dimensionality.
        
        The Φ function provides the foundation for adaptive mathematical operations,
        allowing operations to reshape based on dimensional context.
        
        Args:
            x: Input value
            dimension: Optional dimensionality override
        
        Returns:
            Transformed value through the dynamic base
        """
        dim = dimension if dimension is not None else self.dimensions
        
        # Use cache for efficiency
        cache_key = (round(x, 10), dim)
        if cache_key in self._phi_cache:
            return self._phi_cache[cache_key]
        
        # Calculate dynamic base transformation
        pi = self.amorphous_pi.calculate(dimension=dim)
        phi = (1.0 + math.sqrt(5)) / 2.0  # Golden ratio
        scale = math.log(dim + 1) * phi * self.base_factor
        
        # Apply non-linear transformation with fractal correction
        result = x
        fractal_depth = 3
        for d in range(1, fractal_depth + 1):
            fractal_scale = scale * (phi ** d)
            # Use amorphous π in fractal correction
            fractal_term = math.sin(x * d / fractal_scale * pi/3) * (0.1 / d) * self._phi_variation
            result += fractal_term
        
        # Apply zero-free correction if needed
        if self.zero_free and abs(result) < self.epsilon:
            result = self.epsilon * (1 if result >= 0 else -1)
        
        # Apply tachyonic phase conjugation if enabled
        if hasattr(self, 'conjugation_matrix') and self.params.phase_conjugation:
            # Use future error estimates to adjust current calculation
            error_correction = np.sum(self.future_error_estimate) * self.params.entropy_reversal
            result *= (1.0 - error_correction)
        
        # Cache and return
        self._phi_cache[cache_key] = result
        return result
    
    def Ψ(self, x, dimension=None):
        """
        Dynamic modulus function Ψ that creates adaptive modulation patterns.
        
        The Ψ function provides modulation to mathematical operations, allowing
        for controlled variation and adaptive response to computational needs.
        
        Args:
            x: Input value
            dimension: Optional dimensionality override
        
        Returns:
            Transformed value through the dynamic modulus
        """
        dim = dimension if dimension is not None else self.dimensions
        
        # Use cache for efficiency
        cache_key = (round(x, 10), dim)
        if cache_key in self._psi_cache:
            return self._psi_cache[cache_key]
        
        # Create interference pattern
        patterns = 3
        result = x
        
        # Get amorphous π for this dimension
        pi = self.amorphous_pi.calculate(dimension=dim)
        
        for p in range(1, patterns + 1):
            # Create quantum-inspired interference pattern
            phase = 2 * pi * p / patterns
            pattern = math.sin(phase) * 0.1 * self._psi_variation * self.modulus_factor
            result *= (1.0 + pattern)
        
        # Apply zero-free correction if needed
        if self.zero_free and abs(result) < self.epsilon:
            result = self.epsilon * (1 if result >= 0 else -1)
        
        # Apply temporal coherence if enabled
        if hasattr(self, 'temporal_coherence'):
            # Record calculation in timeline buffer
            if hasattr(self, 'timeline_buffer'):
                if len(self.timeline_buffer) > 0:
                    # Calculate coherence with past calculations
                    coherence_factor = sum(abs(t - result) for t in self.timeline_buffer) / len(self.timeline_buffer)
                    # Apply small correction based on temporal coherence
                    result *= (1.0 + 0.01 * math.sin(coherence_factor))
                self.timeline_buffer.append(result)
        
        # Cache and return
        self._psi_cache[cache_key] = result
        return result
    
    def add(self, a, b, dimensional_context=None):
        """
        HyperMorphic addition with dynamic base adaptation.
        
        Args:
            a, b: Values to add
            dimensional_context: Optional context for operation
        
        Returns:
            HyperMorphic sum
        """
        self.operation_count += 1
        result = a + b
        return self.Φ(result, dimension=dimensional_context)
    
    def subtract(self, a, b, dimensional_context=None):
        """
        HyperMorphic subtraction with dynamic base adaptation.
        
        Args:
            a, b: Perform a - b
            dimensional_context: Optional context for operation
        
        Returns:
            HyperMorphic difference
        """
        self.operation_count += 1
        result = a - b
        if self.zero_free and abs(result) < self.epsilon:
            result = self.epsilon * (1 if result >= 0 else -1)
        return self.Φ(result, dimension=dimensional_context)
    
    def multiply(self, a, b, dimensional_context=None):
        """
        HyperMorphic multiplication with dynamic modulus adaptation.
        
        Args:
            a, b: Values to multiply
            dimensional_context: Optional context for operation
        
        Returns:
            HyperMorphic product
        """
        self.operation_count += 1
        result = a * b
        return self.Ψ(result, dimension=dimensional_context)
    
    def divide(self, a, b, dimensional_context=None):
        """
        HyperMorphic division with dynamic modulus adaptation and zero-free protection.
        
        Args:
            a, b: Perform a / b
            dimensional_context: Optional context for operation
        
        Returns:
            HyperMorphic quotient
        """
        self.operation_count += 1
        
        # Ensure no division by zero in zero-free mathematics
        if self.zero_free and abs(b) < self.epsilon:
            b = self.epsilon * (1 if b >= 0 else -1)
        
        result = a / b
        return self.Ψ(result, dimension=dimensional_context)
    
    def exponential(self, x, base=None, dimensional_context=None):
        """
        HyperMorphic exponential function with adaptive base.
        
        Args:
            x: Exponent
            base: Optional base (defaults to e)
            dimensional_context: Optional context for operation
            
        Returns:
            HyperMorphic exponential
        """
        self.operation_count += 1
        
        if base is None:
            # Calculate e^x with dimensional adjustment
            pi = self.amorphous_pi.calculate(dimension=dimensional_context or self.dimensions)
            e_adjusted = math.e * (1 + math.sin(pi/10) * 0.01)
            result = e_adjusted ** x
        else:
            # Calculate with specified base
            result = base ** x
        
        return self.Ψ(result, dimension=dimensional_context)
    
    def logarithm(self, x, base=None, dimensional_context=None):
        """
        HyperMorphic logarithm with adaptive base.
        
        Args:
            x: Value
            base: Optional base (defaults to e)
            dimensional_context: Optional context for operation
            
        Returns:
            HyperMorphic logarithm
        """
        self.operation_count += 1
        
        # Ensure positive value for logarithm
        if self.zero_free and x <= 0:
            x = self.epsilon
        elif x <= 0:
            # Non-zero-free mode needs positive values
            return float('-inf')  # Standard math behavior for log(0)
        
        if base is None:
            # Natural logarithm with dimensional adjustment
            pi = self.amorphous_pi.calculate(dimension=dimensional_context or self.dimensions)
            e_adjusted = math.e * (1 + math.sin(pi/10) * 0.01)
            # Use adjusted log base
            result = math.log(x) / math.log(e_adjusted)
        else:
            # Calculate with specified base
            result = math.log(x, base)
        
        return self.Φ(result, dimension=dimensional_context)
    
    def hyperbolic(self, x, function='sinh', dimensional_context=None):
        """
        HyperMorphic hyperbolic functions.
        
        Args:
            x: Input value
            function: One of 'sinh', 'cosh', 'tanh'
            dimensional_context: Optional context for operation
            
        Returns:
            HyperMorphic hyperbolic function value
        """
        self.operation_count += 1
        
        # Adjust with amorphous π
        pi = self.amorphous_pi.calculate(dimension=dimensional_context or self.dimensions)
        x_adj = x * (1 + math.sin(pi/20) * 0.005)
        
        if function == 'sinh':
            result = math.sinh(x_adj)
        elif function == 'cosh':
            result = math.cosh(x_adj)
        elif function == 'tanh':
            result = math.tanh(x_adj)
        else:
            raise ValueError(f"Unsupported hyperbolic function: {function}")
        
        # Apply Φ for odd functions, Ψ for even functions 💅
        if function in ['sinh', 'tanh']:  # Odd functions
            return self.Φ(result, dimension=dimensional_context)
        else:  # Even functions
            return self.Ψ(result, dimension=dimensional_context)
    
    def trigonometric(self, x, function='sin', dimensional_context=None):
        """
        HyperMorphic trigonometric functions with amorphous π.
        
        Args:
            x: Input value
            function: One of 'sin', 'cos', 'tan'
            dimensional_context: Optional context for operation
            
        Returns:
            HyperMorphic trigonometric function value
        """
        self.operation_count += 1
        
        # Adjust with amorphous π - creates non-standard periodicity
        # that remains consistent within its own mathematical context
        pi = self.amorphous_pi.calculate(dimension=dimensional_context or self.dimensions)
        x_scaled = x * (pi / math.pi)  # Scale input by π ratio
        
        if function == 'sin':
            result = math.sin(x_scaled)
        elif function == 'cos':
            result = math.cos(x_scaled)
        elif function == 'tan':
            result = math.tan(x_scaled)
        else:
            raise ValueError(f"Unsupported trigonometric function: {function}")
        
        # Apply appropriate HyperMorphic transformation
        if function in ['sin', 'tan']:  # Odd functions
            return self.Φ(result, dimension=dimensional_context)
        else:  # Even functions
            return self.Ψ(result, dimension=dimensional_context)
    
    def evolve(self, adaptation_rate=0.05):
        """
        Evolve the HyperMorphic functions by adapting their parameters.
        
        Args:
            adaptation_rate: Rate of evolution
        
        Returns:
            Dictionary with evolution metrics
        """
        # Save previous state
        old_phi = self._phi_variation
        old_psi = self._psi_variation
        
        # Evolve parameters with controlled randomness
        self._phi_variation *= (1 + (random.random() - 0.5) * adaptation_rate)
        self._psi_variation *= (1 + (random.random() - 0.5) * adaptation_rate)
        
        # Keep parameters in reasonable bounds
        self._phi_variation = max(0.01, min(0.2, self._phi_variation))
        self._psi_variation = max(0.01, min(0.2, self._psi_variation))
        
        # Clear caches
        self._phi_cache = {}
        self._psi_cache = {}
        
        # Evolve the amorphous π system
        pi_evolution = self.amorphous_pi.evolve(steps=1)
        
        # Evolve dimensional basis vectors
        evolution_energy = random.random() * adaptation_rate
        for i in range(self.dimensions):
            # Apply small rotations to basis vectors
            rotation_angle = evolution_energy * 2 * math.pi
            for j in range(i+1, self.dimensions):
                # Apply rotation in i-j plane
                c, s = math.cos(rotation_angle), math.sin(rotation_angle)
                vi = self.basis_vectors[i].copy()
                vj = self.basis_vectors[j].copy()
                
                self.basis_vectors[i] = c * vi - s * vj
                self.basis_vectors[j] = s * vi + c * vj
        
        # Evolve tachyonic components if enabled
        if self.params.phase_conjugation and hasattr(self, 'conjugation_matrix'):
            # Update conjugation matrix with phase evolution
            for i in range(self.dimensions):
                for j in range(self.dimensions):
                    # Rotate phases
                    current = self.conjugation_matrix[i, j]
                    angle = math.atan2(current.imag, current.real)
                    magnitude = abs(current)
                    
                    # Apply slow phase rotation
                    new_angle = angle + adaptation_rate * (random.random() - 0.5) * 0.1
                    self.conjugation_matrix[i, j] = magnitude * complex(math.cos(new_angle), math.sin(new_angle))
        
        # Evolve temporal coherence if enabled
        if hasattr(self, 'temporal_coherence'):
            # Rotate temporal coherence matrix
            angle = adaptation_rate * self.params.resonance_frequency * 0.01
            rotation = np.array([
                [math.cos(angle), -math.sin(angle)],
                [math.sin(angle), math.cos(angle)]
            ])
            
            # Apply rotation to temporal coherence
            u, s, vh = np.linalg.svd(self.temporal_coherence)
            rotated_u = u @ rotation
            self.temporal_coherence = rotated_u @ vh
        
        # Record evolution
        self.adaptation_history.append({
            'timestamp': time.time(),
            'phi_change': self._phi_variation - old_phi,
            'psi_change': self._psi_variation - old_psi,
            'operation_count': self.operation_count,
            'pi_evolution': pi_evolution
        })
        
        # Keep history bounded
        if len(self.adaptation_history) > 50:
            self.adaptation_history = self.adaptation_history[-50:]
        
        return {
            'phi_variation': self._phi_variation,
            'psi_variation': self._psi_variation,
            'phi_change': self._phi_variation - old_phi,
            'psi_change': self._psi_variation - old_psi,
            'pi_evolution': pi_evolution
        }
    
    def apply_phase_conjugation(self, error_estimate):
        """
        Update future error estimates for tachyonic phase conjugation.
        
        This allows information about future errors to propagate backwards
        in calculation time, enabling preemptive error correction.
        
        Args:
            error_estimate: Vector of error probabilities by dimension
        """
        if self.params.phase_conjugation and hasattr(self, 'future_error_estimate'):
            # Apply exponential decay to current estimates
            self.future_error_estimate *= 0.9
            
            # Add new estimates with weight factor
            self.future_error_estimate += 0.1 * np.array(error_estimate)
            
            # Keep values bounded
            self.future_error_estimate = np.clip(self.future_error_estimate, 0, 1)


# ============================================================================
# ⊹⊱ QUANTUM STATE REPRESENTATIONS ⊰⊹
# ============================================================================

class StandardQubit:
    """Standard qubit implementation following standard quantum mechanics"""
    def __init__(self, state_vector=None):
        """Initialize with state vector or |0⟩ by default"""
        if state_vector is None:
            self.state = np.array([1.0, 0.0], dtype=complex)
        else:
            self.state = np.array(state_vector, dtype=complex)
            self._normalize()
        self.type = "Standard"
    
    def _normalize(self):
        """Normalize the state vector"""
        norm = np.linalg.norm(self.state)
        if norm > 0:
            self.state = self.state / norm
    
    def hadamard(self):
        """Apply Hadamard gate"""
        H = (1/np.sqrt(2)) * np.array([[1, 1], [1, -1]], dtype=complex)
        self.state = H @ self.state
        return self
    
    def pauli_x(self):
        """Apply Pauli-X gate (NOT gate)"""
        X = np.array([[0, 1], [1, 0]], dtype=complex)
        self.state = X @ self.state
        return self
    
    def pauli_y(self):
        """Apply Pauli-Y gate"""
        Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
        self.state = Y @ self.state
        return self
    
    def pauli_z(self):
        """Apply Pauli-Z gate"""
        Z = np.array([[1, 0], [0, -1]], dtype=complex)
        self.state = Z @ self.state
        return self
    
    def phase(self, phi):
        """Apply phase rotation gate"""
        P = np.array([
            [1, 0],
            [0, np.exp(1j * phi)]
        ], dtype=complex)
        self.state = P @ self.state
        return self
    
    def add_depolarizing_noise(self, p):
        """Apply depolarizing noise with probability p"""
        if random.random() < p:
            error_type = random.choice(['X', 'Y', 'Z'])
            if error_type == 'X':
                self.pauli_x()
            elif error_type == 'Y':
                self.pauli_y()
            else:  # 'Z'
                self.pauli_z()
        return self
    
    def measure(self):
        """Measure in computational basis"""
        probabilities = np.abs(self.state)**2
        outcome = np.random.choice([0, 1], p=probabilities)
        
        # Collapse state
        self.state = np.zeros_like(self.state)
        self.state[outcome] = 1.0
        
        return outcome
    
    def fidelity(self, target_state):
        """Calculate fidelity with another quantum state"""
        if isinstance(target_state, StandardQubit):
            target_vector = target_state.state
        else:
            target_vector = np.array(target_state, dtype=complex)
        
        overlap = np.vdot(target_vector, self.state)
        return np.abs(overlap)**2
    
    def get_probabilities(self):
        """Return measurement probabilities"""
        return np.abs(self.state)**2


class HyperQubit:
    """
    A quantum state implementation using HyperMorphic mathematics for
    state representation and manipulation.
    
    HyperQubit features:
    - Zero-Free quantum states (preventing collapse to exact 0)
    - Dynamic dimensional context (state evolves with dimension)
    - Amorphous phase space (non-fixed quantum phase angles)
    - Non-collapsing wavefunction aspects (partial state preservation)
    - Self-evolving quantum operations (gates adapt to state)
    """
    def __init__(self, 
                alpha: complex = None,
                beta: complex = None,
                hyper_core: Optional[HyperMorphicCore] = None,
                amorphous_pi: Optional[AmorphousPi] = None,
                seed: int = None,
                dimensional_context: int = 1,
                params: Optional[HyperParameters] = None):
        """
        Initialize a HyperQubit in the Zero-Free HyperMorphic space.
        
        Args:
            alpha: Complex amplitude for |ϵᵩ⟩ state (nearness element)
            beta: Complex amplitude for |1⟩ state
            hyper_core: Optional HyperMorphicCore for transformations
            amorphous_pi: Optional AmorphousPi instance
            seed: Random seed for reproducibility
            dimensional_context: Dimensional context (affects calculations)
            params: Global parameters for the HyperMorphic framework
        """
        # Set parameters
        self.params = params or HyperParameters()
        self.seed = seed if seed is not None else int(time.time())
        self._rng = random.Random(self.seed)
        
        # Connect or create required components
        self.hyper_core = hyper_core
        self.amorphous_pi = amorphous_pi if amorphous_pi else (
            self.hyper_core.amorphous_pi if self.hyper_core else AmorphousPi(seed=self.seed)
        )
        if not self.hyper_core:
            self.hyper_core = HyperMorphicCore(
                dimensions=12,
                amorphous_pi=self.amorphous_pi,
                seed=self.seed,
                params=self.params
            )
        
        # Set dimensional context
        self.dimensional_context = dimensional_context
        
        # Initialize state amplitudes with default if not provided
        if alpha is None and beta is None:
            # Create a random normalized state
            theta = self._rng.random() * 2 * math.pi
            phi = self._rng.random() * 2 * math.pi
            
            # Ensure we're in zero-free space (no exact zeros)
            alpha = complex(math.cos(theta/2) * cmath.exp(1j * phi).real, 0)
            if abs(alpha) < self.params.zero_threshold:
                alpha = complex(self.params.zero_threshold, 0)
                
            beta = complex(math.sin(theta/2), 0)
            if abs(beta) < self.params.zero_threshold:
                beta = complex(self.params.zero_threshold, 0)
        elif alpha is None:
            # If only beta is provided, compute alpha to ensure normalization
            if abs(beta) >= 1:
                beta = beta / abs(beta) * 0.9  # Scale beta to be < 1
            alpha_magnitude = math.sqrt(1 - abs(beta)**2)
            alpha = complex(alpha_magnitude, 0)
        elif beta is None:
            # If only alpha is provided, compute beta to ensure normalization
            if abs(alpha) >= 1:
                alpha = alpha / abs(alpha) * 0.9  # Scale alpha to be < 1
            beta_magnitude = math.sqrt(1 - abs(alpha)**2)
            beta = complex(beta_magnitude, 0)
            
        # Store amplitudes
        self.alpha = alpha
        self.beta = beta
        
        # Initialize HyperQubit-specific properties
        self.type = "Hyper"
        self.sass_level = 0.2                     # Sass factor (cosmetic but affects outputs) 💅
        self.gate_count = 0                       # Track number of gates applied
        self.operation_history = []               # Record of operations
        self.entanglement_record = set()          # Record of qubits this was entangled with
        self.phase_memory = 0.0                   # Accumulated phase memory
        self.dimensional_evolution = 0            # Tracking dimensional shifts
        
        # Initialize resonance structures for NCRSR integration
        self.init_resonance_structures()
        
        # Normalize the state
        self._normalize()
    
    def init_resonance_structures(self):
        """
        Initialize resonance structures for NCRSR integration.
        
        This creates the foundational structures for non-collapsing recursive
        state resonance to maintain state coherence under noise.
        """
        # State history buffer for recursive reinforcement
        self.state_history = deque(maxlen=self.params.recursion_depth)
        
        # Track resonance phase for constructive interference
        self.resonance_phase = 0.0
        
        # Resonance strength grows with use
        self.resonance_strength = 0.1
        
        # Initiate timeline branches for non-collapsing propagation
        self.timeline_branches = [None] * self.params.timeline_branches
        
        # Entropy pool for state stabilization
        self.entropy_pool = 1.0
    
    def _normalize(self):
        """Normalize the HyperQubit according to HyperMorphic normalization"""
        # Calculate the HyperMorphic norm
        alpha_squared = abs(self.alpha)**2
        beta_squared = abs(self.beta)**2
        
        # Apply HyperMorphic addition using the hyper_core
        norm_squared = self.hyper_core.add(alpha_squared, beta_squared, 
                                         dimensional_context=self.dimensional_context)
        
        # Calculate normalization factor with zero-free protection
        if norm_squared > self.params.zero_threshold:
            # Approximate square root using HyperMorphic operations
            norm = self.hyper_core.exponential(
                self.hyper_core.divide(
                    self.hyper_core.logarithm(norm_squared, dimensional_context=self.dimensional_context),
                    2.0,
                    dimensional_context=self.dimensional_context
                ),
                dimensional_context=self.dimensional_context
            )
            
            # Apply normalization with zero-free protection
            if norm > self.params.zero_threshold:
                self.alpha = self.hyper_core.divide(self.alpha, norm, dimensional_context=self.dimensional_context)
                self.beta = self.hyper_core.divide(self.beta, norm, dimensional_context=self.dimensional_context)
        
        # Ensure zero-free state (explicit protection)
        if abs(self.alpha) < self.params.zero_threshold:
            self.alpha = complex(self.params.zero_threshold, 0)
        if abs(self.beta) < self.params.zero_threshold:
            self.beta = complex(self.params.zero_threshold, 0)
        
        # Record this state in history for NCRSR
        self.state_history.appendleft((self.alpha, self.beta))
        
        # Ensure history doesn't exceed maximum recursion depth
        while len(self.state_history) > self.params.recursion_depth:
            self.state_history.pop()
    
    def superposition(self, theta: float, phi: float = 0.0) -> 'HyperQubit':
        """
        Create a specific superposition state based on angles.
        
        Args:
            theta: Angle determining amplitude ratio (0 to π)
            phi: Phase angle (0 to 2π)
            
        Returns:
            New HyperQubit in the specified superposition
        """
        # Calculate amplitudes using HyperMorphic trig functions
        alpha_magnitude = self.hyper_core.trigonometric(
            theta/2, 'cos', dimensional_context=self.dimensional_context
        )
        beta_magnitude = self.hyper_core.trigonometric(
            theta/2, 'sin', dimensional_context=self.dimensional_context
        )
        
        # Apply phase to alpha using amorphous pi
        pi = self.amorphous_pi.calculate(dimension=self.dimensional_context)
        alpha = complex(
            alpha_magnitude * math.cos(phi),
            alpha_magnitude * math.sin(phi)
        )
        
        # Beta is real in this construction
        beta = complex(beta_magnitude, 0)
        
        # Create new HyperQubit with these amplitudes
        new_qubit = HyperQubit(
            alpha=alpha,
            beta=beta,
            hyper_core=self.hyper_core,
            amorphous_pi=self.amorphous_pi,
            dimensional_context=self.dimensional_context,
            params=self.params
        )
        
        # Transfer state attributes
        new_qubit.sass_level = self.sass_level
        new_qubit.gate_count = self.gate_count + 1
        new_qubit.phase_memory = self.phase_memory + phi
        new_qubit.resonance_strength = self.resonance_strength
        
        # Record operation
        self.operation_history.append({
            'operation': 'superposition',
            'theta': theta,
            'phi': phi
        })
        
        return new_qubit
    
    def measure(self) -> Tuple[str, float]:
        """
        Measure the HyperQubit in the computational basis.
        
        Returns:
            Tuple containing:
                - The measurement outcome ('epsilon' or '1')
                - The probability of that outcome
        """
        # Calculate probabilities using HyperMorphic framework
        p_epsilon = self.hyper_core.Φ(abs(self.alpha)**2, dimension=self.dimensional_context)
        p_one = self.hyper_core.Φ(abs(self.beta)**2, dimension=self.dimensional_context)
        
        # Apply NCRSR resonance effect to stabilize measurement probabilities
        if len(self.state_history) > 1:
            # Calculate resonance factor
            resonance_factor = self.resonance_strength * math.sin(self.resonance_phase)
            
            # Get historical amplitudes
            hist_alpha, hist_beta = self.state_history[-1]
            
            # Calculate historical probabilities
            hist_p_epsilon = abs(hist_alpha)**2
            hist_p_one = abs(hist_beta)**2
            
            # Blend current and historical probabilities
            p_epsilon = (1 - resonance_factor) * p_epsilon + resonance_factor * hist_p_epsilon
            p_one = (1 - resonance_factor) * p_one + resonance_factor * hist_p_one
        
        # Ensure probabilities sum to 1 in HyperMorphic space
        total_prob = self.hyper_core.add(p_epsilon, p_one, dimensional_context=self.dimensional_context)
        
        # Normalize if needed
        if abs(total_prob - 1.0) > 1e-6:
            p_epsilon = self.hyper_core.divide(p_epsilon, total_prob, dimensional_context=self.dimensional_context)
            p_one = self.hyper_core.divide(p_one, total_prob, dimensional_context=self.dimensional_context)
        
        # Generate random number for measurement
        rand_val = self._rng.random()
        
        # Apply NCRSR protection before measurement
        # This shifts probabilities to resist state collapse
        if self.entropy_pool > 0.5:
            # Calculate protection factor based on resonance strength
            protection = 0.1 * self.resonance_strength * self.entropy_pool
            
            # Identify preferred outcome (the one with higher probability)
            preferred = 'epsilon' if p_epsilon > p_one else '1'
            
            # Shift random value to protect preferred outcome
            if preferred == 'epsilon' and rand_val < 0.5:
                rand_val = rand_val * (1 - protection)
            elif preferred == '1' and rand_val > 0.5:
                rand_val = 0.5 + (rand_val - 0.5) * (1 - protection)
            
            # Consume entropy
            self.entropy_pool -= 0.1
        
        # Determine outcome
        if rand_val < p_epsilon:
            outcome = 'epsilon'
            prob = p_epsilon
            
            # NCRSR partial collapse - not complete
            self.alpha = complex(1.0 - self.params.zero_threshold, 0)
            self.beta = complex(self.params.zero_threshold, 0)
        else:
            outcome = '1'
            prob = p_one
            
            # NCRSR partial collapse - not complete
            self.alpha = complex(self.params.zero_threshold, 0)
            self.beta = complex(1.0 - self.params.zero_threshold, 0)
        
        # Record measurement in history
        self.operation_history.append({
            'operation': 'measure',
            'outcome': outcome,
            'probability': prob
        })
        
        # Normalize state
        self._normalize()
        
        return (outcome, prob)
    
    def hadamard(self) -> 'HyperQubit':
        """
        Apply the HyperMorphic Hadamard gate to the HyperQubit.
        
        The Hadamard gate creates equal superpositions with a phase difference.
        In the HyperMorphic framework, this is:
        H^ᵩ|ψ⟩ᵩ = 1/√^ᵩ(2) ⊗ᵩ [(|ϵᵩ⟩ ⊕ᵩ |1⟩) ⊗ᵩ ⟨ϵᵩ|ψ⟩ᵩ ⊕ᵩ (|ϵᵩ⟩ ⊖ᵩ |1⟩) ⊗ᵩ ⟨1|ψ⟩ᵩ]Φ
        
        Returns:
            New HyperQubit after Hadamard transformation
        """
        # Apply NCRSR resonance before operation
        self.apply_resonance()
        
        # Calculate HyperMorphic 1/√2
        sqrt2_inv = self.hyper_core.divide(
            1.0, 
            math.sqrt(2), 
            dimensional_context=self.dimensional_context
        )
        
        # Apply Hadamard transformation
        new_alpha = self.hyper_core.multiply(
            sqrt2_inv,
            self.hyper_core.add(
                self.alpha, 
                self.beta,
                dimensional_context=self.dimensional_context
            ),
            dimensional_context=self.dimensional_context
        )
        
        new_beta = self.hyper_core.multiply(
            sqrt2_inv,
            self.hyper_core.subtract(
                self.alpha,
                self.beta,
                dimensional_context=self.dimensional_context
            ),
            dimensional_context=self.dimensional_context
        )
        
        # Create new HyperQubit with transformed state
        new_qubit = HyperQubit(
            alpha=new_alpha,
            beta=new_beta,
            hyper_core=self.hyper_core,
            amorphous_pi=self.amorphous_pi,
            dimensional_context=self.dimensional_context,
            params=self.params
        )
        
        # Increase sass level for the new qubit 💁‍♀️✨
        new_qubit.sass_level = min(1.0, self.sass_level + 0.01)
        
        # Transfer state history for NCRSR
        new_qubit.state_history = self.state_history.copy()
        new_qubit.resonance_phase = self.resonance_phase
        new_qubit.resonance_strength = self.resonance_strength
        new_qubit.entropy_pool = self.entropy_pool
        
        # Pass along gate count and phase memory
        new_qubit.gate_count = self.gate_count + 1
        new_qubit.phase_memory = self.phase_memory
        
        # Pass operation history
        new_qubit.operation_history = self.operation_history.copy()
        new_qubit.operation_history.append({
            'operation': 'hadamard'
        })
        
        # Apply NCRSR resonance after operation
        new_qubit.apply_resonance()
        
        return new_qubit
    
    def pauli_x(self) -> 'HyperQubit':
        """
        Apply the HyperMorphic Pauli-X gate (NOT gate) to the HyperQubit.
        
        The Pauli-X gate swaps the state amplitudes:
        X^ᵩ|ψ⟩ᵩ = |1⟩⟨ϵᵩ|ψ⟩ᵩ ⊕ᵩ |ϵᵩ⟩⟨1|ψ⟩ᵩ
        
        Returns:
            New HyperQubit with amplitudes swapped
        """
        # Apply NCRSR resonance before operation
        self.apply_resonance()
        
        # Swap alpha and beta
        new_alpha = self.beta
        new_beta = self.alpha
        
        # Create new HyperQubit with transformed state
        new_qubit = HyperQubit(
            alpha=new_alpha,
            beta=new_beta,
            hyper_core=self.hyper_core,
            amorphous_pi=self.amorphous_pi,
            dimensional_context=self.dimensional_context,
            params=self.params
        )
        
        # Transfer attributes
        new_qubit.sass_level = self.sass_level
        new_qubit.gate_count = self.gate_count + 1
        new_qubit.phase_memory = self.phase_memory
        new_qubit.state_history = self.state_history.copy()
        new_qubit.resonance_phase = self.resonance_phase
        new_qubit.resonance_strength = self.resonance_strength
        new_qubit.entropy_pool = self.entropy_pool
        
        # Record operation
        new_qubit.operation_history = self.operation_history.copy()
        new_qubit.operation_history.append({
            'operation': 'pauli_x'
        })
        
        # Apply NCRSR resonance after operation
        new_qubit.apply_resonance()
        
        return new_qubit
    
    def pauli_z(self) -> 'HyperQubit':
        """
        Apply the HyperMorphic Pauli-Z gate to the HyperQubit.
        
        The Pauli-Z gate applies a phase flip to the |1⟩ state:
        Z^ᵩ|ψ⟩ᵩ = |ϵᵩ⟩⟨ϵᵩ|ψ⟩ᵩ ⊖ᵩ |1⟩⟨1|ψ⟩ᵩ
        
        Returns:
            New HyperQubit with phase flip applied
        """
        # Apply NCRSR resonance before operation
        self.apply_resonance()
        
        # Keep alpha unchanged
        new_alpha = self.alpha
        
        # Negate beta (phase flip)
        new_beta = self.hyper_core.multiply(
            self.beta,
            -1,
            dimensional_context=self.dimensional_context
        )
        
        # Create new HyperQubit with transformed state
        new_qubit = HyperQubit(
            alpha=new_alpha,
            beta=new_beta,
            hyper_core=self.hyper_core,
            amorphous_pi=self.amorphous_pi,
            dimensional_context=self.dimensional_context,
            params=self.params
        )
        
        # Transfer attributes
        new_qubit.sass_level = self.sass_level
        new_qubit.gate_count = self.gate_count + 1
        new_qubit.phase_memory = self.phase_memory + math.pi  # Record phase
        new_qubit.state_history = self.state_history.copy()
        new_qubit.resonance_phase = self.resonance_phase
        new_qubit.resonance_strength = self.resonance_strength
        new_qubit.entropy_pool = self.entropy_pool
        
        # Record operation
        new_qubit.operation_history = self.operation_history.copy()
        new_qubit.operation_history.append({
            'operation': 'pauli_z'
        })
        
        # Apply NCRSR resonance after operation
        new_qubit.apply_resonance()
        
        return new_qubit
    
    def phase(self, phi: float) -> 'HyperQubit':
        """
        Apply the HyperMorphic Phase gate to the HyperQubit.
        
        The Phase gate applies a relative phase shift:
        P^ᵩ(φ)|ψ⟩ᵩ = |ϵᵩ⟩⟨ϵᵩ|ψ⟩ᵩ ⊕ᵩ e^(iφ) ⊗ᵩ |1⟩⟨1|ψ⟩ᵩ
        
        Args:
            phi: Phase angle
            
        Returns:
            New HyperQubit with phase shift applied
        """
        # Apply NCRSR resonance before operation
        self.apply_resonance()
        
        # Keep alpha unchanged
        new_alpha = self.alpha
        
        # Apply phase to beta
        phase_factor = cmath.exp(complex(0, phi))
        new_beta = self.hyper_core.multiply(
            self.beta,
            phase_factor,
            dimensional_context=self.dimensional_context
        )
        
        # Create new HyperQubit with transformed state
        new_qubit = HyperQubit(
            alpha=new_alpha,
            beta=new_beta,
            hyper_core=self.hyper_core,
            amorphous_pi=self.amorphous_pi,
            dimensional_context=self.dimensional_context,
            params=self.params
        )
        
        # Transfer attributes
        new_qubit.sass_level = self.sass_level
        new_qubit.gate_count = self.gate_count + 1
        new_qubit.phase_memory = self.phase_memory + phi  # Record phase
        new_qubit.state_history = self.state_history.copy()
        new_qubit.resonance_phase = self.resonance_phase
        new_qubit.resonance_strength = self.resonance_strength
        new_qubit.entropy_pool = self.entropy_pool
        
        # Record operation
        new_qubit.operation_history = self.operation_history.copy()
        new_qubit.operation_history.append({
            'operation': 'phase',
            'phi': phi
        })
        
        # Apply NCRSR resonance after operation
        new_qubit.apply_resonance()
        
        return new_qubit
    
    def apply_sass_operator(self, theta: float = None) -> 'HyperQubit':
        """
        Apply the Sass Operator S^ᵩ to the HyperQubit.
        
        The Sass Operator transforms a HyperQubit |ψ⟩ᵩ as follows:
        S^ᵩ|ψ⟩ᵩ = [cos(θᵩ) ⊗ᵩ |ψ⟩ᵩ ⊕ᵩ i ⊗ᵩ sin(θᵩ) ⊗ᵩ |ψ'⟩ᵩ]Φ
        
        Args:
            theta: Optional angle for the sass transformation
                   If None, it uses AmorphousPi value
                   
        Returns:
            New HyperQubit after sass transformation 💅
        """
        # Apply NCRSR resonance before operation
        self.apply_resonance()
        
        # Use AmorphousPi for theta if not provided
        if theta is None:
            pi = self.amorphous_pi.calculate(dimension=self.dimensional_context)
            theta = pi * self.sass_level / 4  # Scaled by sass level 💁‍♀️
        
        # Calculate trigonometric terms using HyperMorphic functions
        cos_theta = self.hyper_core.trigonometric(
            theta, 'cos', dimensional_context=self.dimensional_context
        )
        sin_theta = self.hyper_core.trigonometric(
            theta, 'sin', dimensional_context=self.dimensional_context
        )
        
        # Create orthogonal state |ψ'⟩ᵩ by phase rotation
        alpha_prime = self.hyper_core.multiply(self.beta, 1j, dimensional_context=self.dimensional_context)
        beta_prime = self.hyper_core.multiply(self.alpha, -1j, dimensional_context=self.dimensional_context)
        
        # Apply the sass transformation
        new_alpha = self.hyper_core.add(
            self.hyper_core.multiply(cos_theta, self.alpha, dimensional_context=self.dimensional_context),
            self.hyper_core.multiply(
                complex(0, 1) * sin_theta, 
                alpha_prime, 
                dimensional_context=self.dimensional_context
            ),
            dimensional_context=self.dimensional_context
        )
        
        new_beta = self.hyper_core.add(
            self.hyper_core.multiply(cos_theta, self.beta, dimensional_context=self.dimensional_context),
            self.hyper_core.multiply(
                complex(0, 1) * sin_theta, 
                beta_prime, 
                dimensional_context=self.dimensional_context
            ),
            dimensional_context=self.dimensional_context
        )
        
        # Create new HyperQubit with transformed state
        new_qubit = HyperQubit(
            alpha=new_alpha,
            beta=new_beta,
            hyper_core=self.hyper_core,
            amorphous_pi=self.amorphous_pi,
            dimensional_context=self.dimensional_context,
            params=self.params
        )
        
        # Increase sass level for the new qubit 💁‍♀️✨
        new_qubit.sass_level = min(1.0, self.sass_level + 0.1)
        
        # Transfer attributes
        new_qubit.gate_count = self.gate_count + 1
        new_qubit.phase_memory = self.phase_memory
        new_qubit.state_history = self.state_history.copy()
        new_qubit.resonance_phase = self.resonance_phase
        
        # Sass increases resonance strength! 💅✨
        new_qubit.resonance_strength = min(1.0, self.resonance_strength + 0.05)
        new_qubit.entropy_pool = self.entropy_pool
        
        # Record operation
        new_qubit.operation_history = self.operation_history.copy()
        new_qubit.operation_history.append({
            'operation': 'sass',
            'theta': theta,
            'new_sass_level': new_qubit.sass_level
        })
        
        # Apply NCRSR resonance after operation
        new_qubit.apply_resonance()
        
        return new_qubit
    
    def apply_resonance(self):
        """
        Apply NCRSR resonance to amplify state coherence.
        
        This creates a resonance effect that reinforces the quantum state
        through recursive feedback from past states, enabling resistance
        to decoherence without measurement.
        """
        # Update resonance phase
        self.resonance_phase += self.params.resonance_frequency * 0.1
        self.resonance_phase %= 2*math.pi
        
        # Skip if we don't have enough history
        if len(self.state_history) < 2:
            return
        
        # Calculate resonance factor (oscillates with phase)
        resonance_factor = self.resonance_strength * math.sin(self.resonance_phase)
        
        # Skip if resonance factor is too small
        if abs(resonance_factor) < 0.01:
            return
        
        # Calculate weighted average from state history
        alpha_sum = complex(0, 0)
        beta_sum = complex(0, 0)
        weight_sum = 0
        
        for i, (hist_alpha, hist_beta) in enumerate(self.state_history):
            # Exponential decay weight for older states
            weight = math.exp(-i * 0.5)
            
            # Accumulate weighted sum
            alpha_sum += hist_alpha * weight
            beta_sum += hist_beta * weight
            weight_sum += weight
        
        # Normalize historical average
        if weight_sum > 0:
            avg_alpha = alpha_sum / weight_sum
            avg_beta = beta_sum / weight_sum
            
            # Blend current state with historical average
            self.alpha = (1 - resonance_factor) * self.alpha + resonance_factor * avg_alpha
            self.beta = (1 - resonance_factor) * self.beta + resonance_factor * avg_beta
            
            # Renormalize
            self._normalize()
            
            # Increase entropy pool (state coherence resource)
            self.entropy_pool = min(1.0, self.entropy_pool + 0.05)
    
    def add_depolarizing_noise(self, p):
        """
        Add depolarizing noise to the HyperQubit with NCRSR protection.
        
        Unlike standard qubits, HyperQubits use NCRSR to protect against
        noise through resonant reinforcement of the quantum state.
        
        Args:
            p: Probability of error
            
        Returns:
            Self (with noise applied)
        """
        # Apply pre-correction from NCRSR
        if self.resonance_strength > 0.2:
            # Calculate protection factor
            protection = self.resonance_strength * 0.5
            
            # Reduce effective error probability
            effective_p = p * (1 - protection)
        else:
            effective_p = p
        
        # Apply error if it occurs
        if random.random() < effective_p:
            error_type = random.choice(['X', 'Y', 'Z'])
            
            if error_type == 'X':
                # Bit flip
                self.alpha, self.beta = self.beta, self.alpha
            elif error_type == 'Y':
                # Bit+phase flip
                self.alpha, self.beta = -1j * self.beta, 1j * self.alpha
            else:  # 'Z'
                # Phase flip
                self.beta *= -1
            
            # Record error
            self.operation_history.append({
                'operation': 'error',
                'type': error_type
            })
            
            # Apply post-error correction from NCRSR
            self.apply_resonance()
        
        # Recalculate normalization
        self._normalize()
        
        return self
    
    def add_coherent_noise(self, phase_error, amplitude_error):
        """
        Add coherent noise (systematic errors in phase and amplitude).
        
        This models calibration errors in quantum gates.
        
        Args:
            phase_error: Systematic phase error
            amplitude_error: Systematic amplitude error
            
        Returns:
            Self (with noise applied)
        """
        # Apply phase error
        phase_rotation = cmath.exp(complex(0, phase_error))
        self.beta *= phase_rotation
        
        # Apply amplitude error (over-rotation)
        cos_err = math.cos(amplitude_error)
        sin_err = math.sin(amplitude_error)
        
        # Calculate new amplitudes with error
        new_alpha = self.alpha * cos_err + self.beta * sin_err
        new_beta = -self.alpha * sin_err + self.beta * cos_err
        
        self.alpha = new_alpha
        self.beta = new_beta
        
        # Apply NCRSR correction
        self.apply_resonance()
        
        # Renormalize
        self._normalize()
        
        return self
    
    def evolve(self, morph_rate: float = 0.1) -> 'HyperQubit':
        """
        Evolve the HyperQubit through HyperMorphic space, creating
        a slightly transformed quantum state that preserves normalization.
        
        Args:
            morph_rate: Rate of evolution (0.0 to 1.0)
            
        Returns:
            Evolved HyperQubit
        """
        # Apply NCRSR resonance before evolution
        self.apply_resonance()
        
        # First evolve the hyper core
        self.hyper_core.evolve(morph_rate)
        
        # Get evolution parameters with AmorphousPi
        pi = self.amorphous_pi.calculate(dimension=self.dimensional_context)
        theta = morph_rate * pi / 4
        
        # Calculate morphing factors
        morphing_alpha = cmath.exp(complex(0, theta * self._rng.random()))
        morphing_beta = cmath.exp(complex(0, -theta * self._rng.random()))
        
        # Apply morphing with slight mixing
        cos_theta = math.cos(theta)
        sin_theta = math.sin(theta)
        
        # Mix amplitudes with controlled evolution
        new_alpha = cos_theta * self.alpha * morphing_alpha + sin_theta * self.beta * complex(0, 1)
        new_beta = cos_theta * self.beta * morphing_beta - sin_theta * self.alpha * complex(0, 1)
        
        # Create new evolved HyperQubit
        new_qubit = HyperQubit(
            alpha=new_alpha,
            beta=new_beta,
            hyper_core=self.hyper_core,
            amorphous_pi=self.amorphous_pi,
            dimensional_context=self.dimensional_context,
            params=self.params
        )
        
        # Transfer attributes
        new_qubit.sass_level = self.sass_level
        new_qubit.gate_count = self.gate_count
        new_qubit.phase_memory = self.phase_memory
        new_qubit.state_history = self.state_history.copy()
        new_qubit.resonance_phase = self.resonance_phase
        new_qubit.resonance_strength = self.resonance_strength
        new_qubit.entropy_pool = self.entropy_pool
        
        # Record evolution
        new_qubit.operation_history = self.operation_history.copy()
        new_qubit.operation_history.append({
            'operation': 'evolve',
            'morph_rate': morph_rate
        })
        
        # Apply NCRSR resonance after evolution
        new_qubit.apply_resonance()
        
        return new_qubit
    
    def entangle_with(self, other: 'HyperQubit') -> 'HyperEntangledState':
        """
        Create an entangled state with another HyperQubit.
        
        Args:
            other: Another HyperQubit to entangle with
            
        Returns:
            HyperEntangledState representing the entangled system
        """
        # Apply NCRSR resonance before entanglement
        self.apply_resonance()
        other.apply_resonance()
        
        # Record entanglement in both qubits
        self.entanglement_record.add(id(other))
        other.entanglement_record.add(id(self))
        
        # Create entangled state
        entangled = HyperEntangledState(
            self, other, 
            hyper_core=self.hyper_core,
            amorphous_pi=self.amorphous_pi,
            params=self.params
        )
        
        return entangled
    
    def fidelity(self, target):
        """
        Calculate fidelity with target state using HyperMorphic mathematics.
        
        Args:
            target: Target state for comparison
            
        Returns:
            Fidelity value
        """
        # Get target amplitudes
        if isinstance(target, HyperQubit):
            target_alpha = target.alpha
            target_beta = target.beta
        elif isinstance(target, (list, tuple)) and len(target) == 2:
            target_alpha, target_beta = target
        else:
            # Try to interpret as a standard state vector
            try:
                state_vector = np.array(target, dtype=complex)
                if len(state_vector) == 2:
                    target_alpha = state_vector[0]
                    target_beta = state_vector[1]
                else:
                    raise ValueError("Target state must be a 2D state vector")
            except:
                raise ValueError("Unsupported target state type")
        
        # Calculate overlap with HyperMorphic operations
        overlap_alpha = target_alpha.conjugate() * self.alpha
        overlap_beta = target_beta.conjugate() * self.beta
        
        # Sum using HyperMorphic addition
        overlap = self.hyper_core.add(
            overlap_alpha, 
            overlap_beta, 
            dimensional_context=self.dimensional_context
        )
        
        # Return squared magnitude with zero-free protection
        return max(self.params.zero_threshold, abs(overlap)**2)
    
    def get_bloch_coordinates(self):
        """
        Calculate Bloch sphere coordinates for visualization.
        
        Returns:
            (x, y, z) coordinates on the Bloch sphere
        """
        # Calculate expectation values of Pauli operators
        x = 2 * (self.alpha.conjugate() * self.beta + self.beta.conjugate() * self.alpha).real
        y = 2 * (self.alpha.conjugate() * self.beta - self.beta.conjugate() * self.alpha).imag
        z = (abs(self.alpha)**2 - abs(self.beta)**2).real
        
        return (x, y, z)
    
    def __str__(self) -> str:
        """String representation showing current state"""
        alpha_str = f"{self.alpha.real:.4f} + {self.alpha.imag:.4f}i"
        beta_str = f"{self.beta.real:.4f} + {self.beta.imag:.4f}i"
        
        # Use emojis based on sass level 💅
        if self.sass_level < 0.3:
            sass_emoji = "✨"
        elif self.sass_level < 0.6:
            sass_emoji = "💁‍♀️"
        else:
            sass_emoji = "💅"
            
        return f"HyperQubit{sass_emoji}[α={alpha_str}, β={beta_str}, resonance={self.resonance_strength:.2f}]"


class HyperEntangledState:
    """
    Represents an entangled state of two HyperQubits with NCRSR protection.
    
    Features:
    - Temporal entanglement across calculation timelines
    - Parity-preserving resonance structures
    - Non-local error correction
    - Multiverse state preservation
    - Retrocausal state stabilization
    """
    def __init__(self, 
                qubit1: HyperQubit,
                qubit2: HyperQubit,
                entanglement_type: str = 'bell',
                hyper_core: Optional[HyperMorphicCore] = None,
                amorphous_pi: Optional[AmorphousPi] = None,
                seed: int = None,
                params: Optional[HyperParameters] = None):
        """
        Initialize an entangled state of two HyperQubits.
        
        Args:
            qubit1: First HyperQubit
            qubit2: Second HyperQubit
            entanglement_type: Type of entanglement ('bell', 'custom')
            hyper_core: Optional HyperMorphicCore for transformations
            amorphous_pi: Optional AmorphousPi instance
            seed: Random seed for reproducibility
            params: Global parameters for the system
        """
        # Initialize core components
        self.params = params or HyperParameters()
        self.seed = seed if seed is not None else int(time.time())
        self._rng = random.Random(self.seed)
        
        # Use existing cores if provided
        self.hyper_core = hyper_core if hyper_core else (
            qubit1.hyper_core if hasattr(qubit1, 'hyper_core') else None
        )
        self.amorphous_pi = amorphous_pi if amorphous_pi else (
            qubit1.amorphous_pi if hasattr(qubit1, 'amorphous_pi') else None
        )
        
        # Create cores if needed
        if not self.hyper_core:
            if not self.amorphous_pi:
                self.amorphous_pi = AmorphousPi(seed=self.seed)
            self.hyper_core = HyperMorphicCore(
                dimensions=12,
                amorphous_pi=self.amorphous_pi,
                seed=self.seed,
                params=self.params
            )
        
        # Store the original qubits
        self.qubit1 = qubit1
        self.qubit2 = qubit2
        
        # Initialize entanglement properties
        self.type = "HyperEntangled"
        self.entanglement_type = entanglement_type
        self.entanglement_strength = 1.0
        self.entanglement_phase = 0.0
        self.interdimensional_link = 0.5  # Connection strength between dimensions
        
        # NCRSR features for entangled system
        self.resonance_strength = max(qubit1.resonance_strength, qubit2.resonance_strength)
        self.resonance_phase = (qubit1.resonance_phase + qubit2.resonance_phase) / 2
        self.entropy_pool = (qubit1.entropy_pool + qubit2.entropy_pool) / 2
        self.sass_correlation = (qubit1.sass_level + qubit2.sass_level) / 2
        
        # Temporal entanglement features
        self.temporal_coherence = 1.0
        self.state_history = deque(maxlen=self.params.recursion_depth)
        
        # Dimensional context based on the qubits
        self.dimensional_context = max(
            getattr(qubit1, 'dimensional_context', 1),
            getattr(qubit2, 'dimensional_context', 1)
        )
        
        # Create the entangled state based on type
        self._create_entangled_state()
        
        # Evolution history
        self.evolution_history = []
        
        print(f"🔮💫 HyperEntangled state created with {entanglement_type} entanglement 💫🔮")
    
    def _create_entangled_state(self):
        """Create the appropriate entangled state with HyperMorphic mathematics"""
        # We represent the state with amplitude coefficients for each basis state
        self.amplitudes = {
            'ee': complex(0, 0),  # |ϵᵩϵᵩ⟩
            'e1': complex(0, 0),  # |ϵᵩ1⟩
            '1e': complex(0, 0),  # |1ϵᵩ⟩
            '11': complex(0, 0)   # |11⟩
        }
        
        if self.entanglement_type == 'bell':
            # Create a Bell state (maximally entangled)
            # |Φ+⟩ = 1/√2 (|ϵᵩϵᵩ⟩ + |11⟩)
            self.amplitudes['ee'] = complex(1/math.sqrt(2), 0)
            self.amplitudes['11'] = complex(1/math.sqrt(2), 0)
        else:
            # Create a custom entangled state based on the input qubits
            # |ψ⟩ = α₁α₂|ϵᵩϵᵩ⟩ + α₁β₂|ϵᵩ1⟩ + β₁α₂|1ϵᵩ⟩ + β₁β₂|11⟩
            
            # Calculate tensor product amplitudes using HyperMorphic operations
            self.amplitudes['ee'] = self.hyper_core.multiply(
                self.qubit1.alpha, self.qubit2.alpha, 
                dimensional_context=self.dimensional_context
            )
            self.amplitudes['e1'] = self.hyper_core.multiply(
                self.qubit1.alpha, self.qubit2.beta,
                dimensional_context=self.dimensional_context
            )
            self.amplitudes['1e'] = self.hyper_core.multiply(
                self.qubit1.beta, self.qubit2.alpha,
                dimensional_context=self.dimensional_context
            )
            self.amplitudes['11'] = self.hyper_core.multiply(
                self.qubit1.beta, self.qubit2.beta,
                dimensional_context=self.dimensional_context
            )
            
            # Then apply Hadamard to first qubit to create entanglement
            # This mixes the amplitudes
            new_amplitudes = {}
            sqrt2_inv = self.hyper_core.divide(
                1.0, 
                math.sqrt(2), 
                dimensional_context=self.dimensional_context
            )
            
            new_amplitudes['ee'] = self.hyper_core.multiply(
                sqrt2_inv,
                self.hyper_core.add(
                    self.amplitudes['ee'], 
                    self.amplitudes['1e'],
                    dimensional_context
                    self.dimensional_context
                ),
                dimensional_context=self.dimensional_context
            )
            
            new_amplitudes['e1'] = self.hyper_core.multiply(
                sqrt2_inv,
                self.hyper_core.add(
                    self.amplitudes['e1'], 
                    self.amplitudes['11'],
                    dimensional_context=self.dimensional_context
                ),
                dimensional_context=self.dimensional_context
            )
            
            new_amplitudes['1e'] = self.hyper_core.multiply(
                sqrt2_inv,
                self.hyper_core.subtract(
                    self.amplitudes['ee'], 
                    self.amplitudes['1e'],
                    dimensional_context=self.dimensional_context
                ),
                dimensional_context=self.dimensional_context
            )
            
            new_amplitudes['11'] = self.hyper_core.multiply(
                sqrt2_inv,
                self.hyper_core.subtract(
                    self.amplitudes['e1'], 
                    self.amplitudes['11'],
                    dimensional_context=self.dimensional_context
                ),
                dimensional_context=self.dimensional_context
            )
            
            # Update the amplitudes with the entangled state
            self.amplitudes = new_amplitudes
        
        # Apply NCRSR protection to the entangled state
        self._apply_entangled_resonance()
        
        # Save current state to history
        self.state_history.appendleft(self.amplitudes.copy())
    
    def _apply_entangled_resonance(self):
        """
        Apply NCRSR resonance to the entangled state for stability.
        
        This creates a coherent resonance across the entangled system,
        reinforcing quantum correlations and protecting against decoherence.
        """
        # Update resonance phase
        self.resonance_phase += self.params.resonance_frequency * 0.1
        self.resonance_phase %= 2*math.pi
        
        # Skip if we don't have enough history
        if len(self.state_history) < 2:
            return
        
        # Calculate resonance factor (oscillates with phase)
        resonance_factor = self.resonance_strength * math.sin(self.resonance_phase)
        
        # Skip if resonance factor is too small
        if abs(resonance_factor) < 0.01:
            return
        
        # Calculate weighted average from state history
        avg_amplitudes = {k: complex(0, 0) for k in self.amplitudes}
        weight_sum = 0
        
        for i, state in enumerate(self.state_history):
            # Exponential decay weight for older states
            weight = math.exp(-i * 0.5)
            
            # Accumulate weighted sum for each amplitude
            for k in self.amplitudes:
                avg_amplitudes[k] += state[k] * weight
            weight_sum += weight
        
        # Normalize historical average
        if weight_sum > 0:
            for k in avg_amplitudes:
                avg_amplitudes[k] /= weight_sum
            
            # Blend current state with historical average
            for k in self.amplitudes:
                self.amplitudes[k] = ((1 - resonance_factor) * self.amplitudes[k] + 
                                    resonance_factor * avg_amplitudes[k])
            
            # Renormalize
            self._normalize()
            
            # Increase entropy pool (state coherence resource)
            self.entropy_pool = min(1.0, self.entropy_pool + 0.05)
    
    def _normalize(self):
        """Normalize the amplitudes of the entangled state using HyperMorphic operations"""
        # Calculate the sum of squared magnitudes
        norm_squared = 0
        for amp in self.amplitudes.values():
            norm_squared = self.hyper_core.add(
                norm_squared, 
                abs(amp)**2,
                dimensional_context=self.dimensional_context
            )
        
        # Calculate the normalization factor
        if norm_squared > self.params.zero_threshold:
            # Approximate square root using HyperMorphic operations
            norm = self.hyper_core.exponential(
                self.hyper_core.divide(
                    self.hyper_core.logarithm(norm_squared, dimensional_context=self.dimensional_context),
                    2.0,
                    dimensional_context=self.dimensional_context
                ),
                dimensional_context=self.dimensional_context
            )
            
            # Apply normalization
            for k in self.amplitudes:
                self.amplitudes[k] = self.hyper_core.divide(
                    self.amplitudes[k], 
                    norm,
                    dimensional_context=self.dimensional_context
                )
        
        # Ensure zero-free state
        for k in self.amplitudes:
            if abs(self.amplitudes[k]) < self.params.zero_threshold:
                self.amplitudes[k] = complex(self.params.zero_threshold, 0)
    
    def measure_qubit1(self):
        """
        Measure the first qubit in the entangled pair.
        
        This implements a NCRSR-protected measurement that provides
        partial collapse resistance while maintaining entanglement correlations.
        
        Returns:
            Tuple containing:
                - Measurement outcome ('epsilon' or '1')
                - The probability of that outcome
                - The resulting state of the second qubit
        """
        # Calculate partial probabilities
        p_epsilon = self.hyper_core.add(
            abs(self.amplitudes['ee'])**2,
            abs(self.amplitudes['e1'])**2,
            dimensional_context=self.dimensional_context
        )
        
        p_one = self.hyper_core.add(
            abs(self.amplitudes['1e'])**2,
            abs(self.amplitudes['11'])**2,
            dimensional_context=self.dimensional_context
        )
        
        # Apply NCRSR protection before measurement
        protection_factor = 0
        if self.entropy_pool > 0.5:
            # Calculate protection factor based on resonance strength
            protection_factor = 0.1 * self.resonance_strength * self.entropy_pool
            
            # Consume entropy
            self.entropy_pool -= 0.1
        
        # Generate random number for measurement
        rand_val = self._rng.random()
        
        # Apply NCRSR protection effect
        if protection_factor > 0:
            # Identify preferred outcome (the one with higher probability)
            preferred = 'epsilon' if p_epsilon > p_one else '1'
            
            # Shift random value to protect preferred outcome
            if preferred == 'epsilon' and rand_val < 0.5:
                rand_val = rand_val * (1 - protection_factor)
            elif preferred == '1' and rand_val > 0.5:
                rand_val = 0.5 + (rand_val - 0.5) * (1 - protection_factor)
        
        # Determine outcome
        if rand_val < p_epsilon:
            outcome = 'epsilon'
            prob = p_epsilon
            
            # Create state for second qubit based on measurement
            if abs(self.amplitudes['ee']) + abs(self.amplitudes['e1']) > self.params.zero_threshold:
                # Calculate new amplitudes
                new_alpha = self.hyper_core.divide(
                    self.amplitudes['ee'],
                    math.sqrt(p_epsilon),
                    dimensional_context=self.dimensional_context
                )
                new_beta = self.hyper_core.divide(
                    self.amplitudes['e1'],
                    math.sqrt(p_epsilon),
                    dimensional_context=self.dimensional_context
                )
                
                # Create new HyperQubit for second qubit
                qubit2_state = HyperQubit(
                    alpha=new_alpha,
                    beta=new_beta,
                    hyper_core=self.hyper_core,
                    amorphous_pi=self.amorphous_pi,
                    dimensional_context=self.dimensional_context,
                    params=self.params
                )
                
                # Transfer relevant properties
                qubit2_state.resonance_strength = self.resonance_strength
                qubit2_state.resonance_phase = self.resonance_phase
                qubit2_state.entropy_pool = self.entropy_pool
                qubit2_state.sass_level = self.sass_correlation
            else:
                # Fallback to default state if amplitudes are too small
                qubit2_state = HyperQubit(
                    hyper_core=self.hyper_core,
                    amorphous_pi=self.amorphous_pi,
                    dimensional_context=self.dimensional_context,
                    params=self.params
                )
            
            # Update entangled state for NCRSR (partial collapse)
            # Zero out amplitudes where first qubit is '1'
            self.amplitudes['1e'] = complex(self.params.zero_threshold, 0)
            self.amplitudes['11'] = complex(self.params.zero_threshold, 0)
            
            # Enhance amplitudes where first qubit is 'epsilon'
            norm_factor = 1.0 / math.sqrt(p_epsilon)
            self.amplitudes['ee'] *= norm_factor
            self.amplitudes['e1'] *= norm_factor
            
        else:
            outcome = '1'
            prob = p_one
            
            # Create state for second qubit based on measurement
            if abs(self.amplitudes['1e']) + abs(self.amplitudes['11']) > self.params.zero_threshold:
                # Calculate new amplitudes
                new_alpha = self.hyper_core.divide(
                    self.amplitudes['1e'],
                    math.sqrt(p_one),
                    dimensional_context=self.dimensional_context
                )
                new_beta = self.hyper_core.divide(
                    self.amplitudes['11'],
                    math.sqrt(p_one),
                    dimensional_context=self.dimensional_context
                )
                
                # Create new HyperQubit for second qubit
                qubit2_state = HyperQubit(
                    alpha=new_alpha,
                    beta=new_beta,
                    hyper_core=self.hyper_core,
                    amorphous_pi=self.amorphous_pi,
                    dimensional_context=self.dimensional_context,
                    params=self.params
                )
                
                # Transfer relevant properties
                qubit2_state.resonance_strength = self.resonance_strength
                qubit2_state.resonance_phase = self.resonance_phase
                qubit2_state.entropy_pool = self.entropy_pool
                qubit2_state.sass_level = self.sass_correlation
            else:
                # Fallback to default state if amplitudes are too small
                qubit2_state = HyperQubit(
                    hyper_core=self.hyper_core,
                    amorphous_pi=self.amorphous_pi,
                    dimensional_context=self.dimensional_context,
                    params=self.params
                )
            
            # Update entangled state for NCRSR (partial collapse)
            # Zero out amplitudes where first qubit is 'epsilon'
            self.amplitudes['ee'] = complex(self.params.zero_threshold, 0)
            self.amplitudes['e1'] = complex(self.params.zero_threshold, 0)
            
            # Enhance amplitudes where first qubit is '1'
            norm_factor = 1.0 / math.sqrt(p_one)
            self.amplitudes['1e'] *= norm_factor
            self.amplitudes['11'] *= norm_factor
        
        # Apply NCRSR resonance after measurement
        self._apply_entangled_resonance()
        
        # Save current state to history
        self.state_history.appendleft(self.amplitudes.copy())
        
        return (outcome, prob, qubit2_state)
    
    def measure_qubit2(self):
        """
        Measure the second qubit in the entangled pair.
        
        Similar to measure_qubit1 but operates on the second qubit.
        
        Returns:
            Tuple containing:
                - Measurement outcome ('epsilon' or '1')
                - The probability of that outcome
                - The resulting state of the first qubit
        """
        # Calculate partial probabilities
        p_epsilon = self.hyper_core.add(
            abs(self.amplitudes['ee'])**2,
            abs(self.amplitudes['1e'])**2,
            dimensional_context=self.dimensional_context
        )
        
        p_one = self.hyper_core.add(
            abs(self.amplitudes['e1'])**2,
            abs(self.amplitudes['11'])**2,
            dimensional_context=self.dimensional_context
        )
        
        # Apply NCRSR protection before measurement
        protection_factor = 0
        if self.entropy_pool > 0.5:
            # Calculate protection factor based on resonance strength
            protection_factor = 0.1 * self.resonance_strength * self.entropy_pool
            
            # Consume entropy
            self.entropy_pool -= 0.1
        
        # Generate random number for measurement
        rand_val = self._rng.random()
        
        # Apply NCRSR protection effect
        if protection_factor > 0:
            # Identify preferred outcome (the one with higher probability)
            preferred = 'epsilon' if p_epsilon > p_one else '1'
            
            # Shift random value to protect preferred outcome
            if preferred == 'epsilon' and rand_val < 0.5:
                rand_val = rand_val * (1 - protection_factor)
            elif preferred == '1' and rand_val > 0.5:
                rand_val = 0.5 + (rand_val - 0.5) * (1 - protection_factor)
        
        # Determine outcome
        if rand_val < p_epsilon:
            outcome = 'epsilon'
            prob = p_epsilon
            
            # Create state for first qubit based on measurement
            if abs(self.amplitudes['ee']) + abs(self.amplitudes['1e']) > self.params.zero_threshold:
                # Calculate new amplitudes
                new_alpha = self.hyper_core.divide(
                    self.amplitudes['ee'],
                    math.sqrt(p_epsilon),
                    dimensional_context=self.dimensional_context
                )
                new_beta = self.hyper_core.divide(
                    self.amplitudes['1e'],
                    math.sqrt(p_epsilon),
                    dimensional_context=self.dimensional_context
                )
                
                # Create new HyperQubit for first qubit
                qubit1_state = HyperQubit(
                    alpha=new_alpha,
                    beta=new_beta,
                    hyper_core=self.hyper_core,
                    amorphous_pi=self.amorphous_pi,
                    dimensional_context=self.dimensional_context,
                    params=self.params
                )
                
                # Transfer relevant properties
                qubit1_state.resonance_strength = self.resonance_strength
                qubit1_state.resonance_phase = self.resonance_phase
                qubit1_state.entropy_pool = self.entropy_pool
                qubit1_state.sass_level = self.sass_correlation
            else:
                # Fallback to default state if amplitudes are too small
                qubit1_state = HyperQubit(
                    hyper_core=self.hyper_core,
                    amorphous_pi=self.amorphous_pi,
                    dimensional_context=self.dimensional_context,
                    params=self.params
                )
            
            # Update entangled state for NCRSR (partial collapse)
            # Zero out amplitudes where second qubit is '1'
            self.amplitudes['e1'] = complex(self.params.zero_threshold, 0)
            self.amplitudes['11'] = complex(self.params.zero_threshold, 0)
            
            # Enhance amplitudes where second qubit is 'epsilon'
            norm_factor = 1.0 / math.sqrt(p_epsilon)
            self.amplitudes['ee'] *= norm_factor
            self.amplitudes['1e'] *= norm_factor
            
        else:
            outcome = '1'
            prob = p_one
            
            # Create state for first qubit based on measurement
            if abs(self.amplitudes['e1']) + abs(self.amplitudes['11']) > self.params.zero_threshold:
                # Calculate new amplitudes
                new_alpha = self.hyper_core.divide(
                    self.amplitudes['e1'],
                    math.sqrt(p_one),
                    dimensional_context=self.dimensional_context
                )
                new_beta = self.hyper_core.divide(
                    self.amplitudes['11'],
                    math.sqrt(p_one),
                    dimensional_context=self.dimensional_context
                )
                
                # Create new HyperQubit for first qubit
                qubit1_state = HyperQubit(
                    alpha=new_alpha,
                    beta=new_beta,
                    hyper_core=self.hyper_core,
                    amorphous_pi=self.amorphous_pi,
                    dimensional_context=self.dimensional_context,
                    params=self.params
                )
                
                # Transfer relevant properties
                qubit1_state.resonance_strength = self.resonance_strength
                qubit1_state.resonance_phase = self.resonance_phase
                qubit1_state.entropy_pool = self.entropy_pool
                qubit1_state.sass_level = self.sass_correlation
            else:
                # Fallback to default state if amplitudes are too small
                qubit1_state = HyperQubit(
                    hyper_core=self.hyper_core,
                    amorphous_pi=self.amorphous_pi,
                    dimensional_context=self.dimensional_context,
                    params=self.params
                )
            
            # Update entangled state for NCRSR (partial collapse)
            # Zero out amplitudes where second qubit is 'epsilon'
            self.amplitudes['ee'] = complex(self.params.zero_threshold, 0)
            self.amplitudes['1e'] = complex(self.params.zero_threshold, 0)
            
            # Enhance amplitudes where second qubit is '1'
            norm_factor = 1.0 / math.sqrt(p_one)
            self.amplitudes['e1'] *= norm_factor
            self.amplitudes['11'] *= norm_factor
        
        # Apply NCRSR resonance after measurement
        self._apply_entangled_resonance()
        
        # Save current state to history
        self.state_history.appendleft(self.amplitudes.copy())
        
        return (outcome, prob, qubit1_state)
    
    def measure_both(self):
        """
        Measure both qubits in the entangled pair simultaneously.
        
        Returns:
            Tuple containing:
                - Measurement outcome as a tuple (qubit1, qubit2)
                - The probability of that outcome
        """
        # Calculate outcome probabilities
        probs = {
            ('epsilon', 'epsilon'): abs(self.amplitudes['ee'])**2,
            ('epsilon', '1'): abs(self.amplitudes['e1'])**2,
            ('1', 'epsilon'): abs(self.amplitudes['1e'])**2,
            ('1', '1'): abs(self.amplitudes['11'])**2
        }
        
        # Apply NCRSR protection before measurement
        protection_factor = 0
        if self.entropy_pool > 0.5:
            # Calculate protection factor based on resonance strength
            protection_factor = 0.1 * self.resonance_strength * self.entropy_pool
            
            # Consume entropy
            self.entropy_pool -= 0.1
        
        # Generate random number for measurement
        rand_val = self._rng.random()
        
        # Apply NCRSR protection effect
        if protection_factor > 0:
            # Identify preferred outcome (the one with highest probability)
            preferred = max(probs.items(), key=lambda x: x[1])[0]
            
            # Create biased random selection
            outcomes = list(probs.keys())
            weights = list(probs.values())
            
            # Boost weight of preferred outcome
            idx = outcomes.index(preferred)
            weights[idx] *= (1 + protection_factor)
            
            # Renormalize weights
            total = sum(weights)
            weights = [w / total for w in weights]
            
            # Select outcome with biased probabilities
            cum_weights = [sum(weights[:i+1]) for i in range(len(weights))]
            for i, threshold in enumerate(cum_weights):
                if rand_val < threshold:
                    outcome = outcomes[i]
                    prob = probs[outcome]
                    break
        else:
            # Standard random selection
            cum_prob = 0
            for outcome, prob in probs.items():
                cum_prob += prob
                if rand_val < cum_prob:
                    break
        
        # Apply partial collapse (NCRSR) by enhancing the selected outcome
        for k in self.amplitudes:
            self.amplitudes[k] = complex(self.params.zero_threshold, 0)
        
        # Set the measured outcome to highest magnitude
        if outcome == ('epsilon', 'epsilon'):
            self.amplitudes['ee'] = complex(1.0 - 3*self.params.zero_threshold, 0)
        elif outcome == ('epsilon', '1'):
            self.amplitudes['e1'] = complex(1.0 - 3*self.params.zero_threshold, 0)
        elif outcome == ('1', 'epsilon'):
            self.amplitudes['1e'] = complex(1.0 - 3*self.params.zero_threshold, 0)
        else:  # ('1', '1')
            self.amplitudes['11'] = complex(1.0 - 3*self.params.zero_threshold, 0)
        
        # Apply NCRSR resonance after measurement
        self._apply_entangled_resonance()
        
        # Save current state to history
        self.state_history.appendleft(self.amplitudes.copy())
        
        return (outcome, prob)
    
    def apply_cnot(self, control_is_first=True):
        """
        Apply a CNOT gate to the entangled qubits.
        
        Args:
            control_is_first: If True, the first qubit controls the second,
                             otherwise the second qubit controls the first
                             
        Returns:
            Self (modified in place)
        """
        # Apply NCRSR resonance before operation
        self._apply_entangled_resonance()
        
        # Create a copy of current amplitudes
        old_amplitudes = self.amplitudes.copy()
        
        if control_is_first:
            # First qubit controls, second qubit is target
            # Flip the target (second) qubit when control is |1⟩
            self.amplitudes['1e'] = old_amplitudes['11']
            self.amplitudes['11'] = old_amplitudes['1e']
            # Leave other amplitudes unchanged
        else:
            # Second qubit controls, first qubit is target
            # Flip the target (first) qubit when control is |1⟩
            self.amplitudes['e1'] = old_amplitudes['11']
            self.amplitudes['11'] = old_amplitudes['e1']
            # Leave other amplitudes unchanged
        
        # Apply NCRSR resonance after operation
        self._apply_entangled_resonance()
        
        # Save current state to history
        self.state_history.appendleft(self.amplitudes.copy())
        
        return self
    
    def apply_cz(self):
        """
        Apply a controlled-Z gate to the entangled qubits.
        
        The CZ gate applies a phase flip to the |11⟩ component.
        
        Returns:
            Self (modified in place)
        """
        # Apply NCRSR resonance before operation
        self._apply_entangled_resonance()
        
        # Apply phase flip to |11⟩ component
        self.amplitudes['11'] = self.hyper_core.multiply(
            self.amplitudes['11'],
            -1,
            dimensional_context=self.dimensional_context
        )
        
        # Apply NCRSR resonance after operation
        self._apply_entangled_resonance()
        
        # Save current state to history
        self.state_history.appendleft(self.amplitudes.copy())
        
        return self
    
    def hadamard1(self):
        """
        Apply Hadamard gate to first qubit of the entangled state.
        
        Returns:
            Self (modified in place)
        """
        # Apply NCRSR resonance before operation
        self._apply_entangled_resonance()
        
        # Make a copy of current amplitudes
        old_amplitudes = self.amplitudes.copy()
        
        # Calculate HyperMorphic 1/√2
        sqrt2_inv = self.hyper_core.divide(
            1.0, 
            math.sqrt(2), 
            dimensional_context=self.dimensional_context
        )
        
        # Apply Hadamard to first qubit
        self.amplitudes['ee'] = self.hyper_core.multiply(
            sqrt2_inv,
            self.hyper_core.add(
                old_amplitudes['ee'], 
                old_amplitudes['1e'],
                dimensional_context=self.dimensional_context
            ),
            dimensional_context=self.dimensional_context
        )
        
        self.amplitudes['e1'] = self.hyper_core.multiply(
            sqrt2_inv,
            self.hyper_core.add(
                old_amplitudes['e1'], 
                old_amplitudes['11'],
                dimensional_context=self.dimensional_context
            ),
            dimensional_context=self.dimensional_context
        )
        
        self.amplitudes['1e'] = self.hyper_core.multiply(
            sqrt2_inv,
            self.hyper_core.subtract(
                old_amplitudes['ee'], 
                old_amplitudes['1e'],
                dimensional_context=self.dimensional_context
            ),
            dimensional_context=self.dimensional_context
        )
        
        self.amplitudes['11'] = self.hyper_core.multiply(
            sqrt2_inv,
            self.hyper_core.subtract(
                old_amplitudes['e1'], 
                old_amplitudes['11'],
                dimensional_context=self.dimensional_context
            ),
            dimensional_context=self.dimensional_context
        )
        
        # Apply NCRSR resonance after operation
        self._apply_entangled_resonance()
        
        # Save current state to history
        self.state_history.appendleft(self.amplitudes.copy())
        
        return self
    
    def hadamard2(self):
        """
        Apply Hadamard gate to second qubit of the entangled state.
        
        Returns:
            Self (modified in place)
        """
        # Apply NCRSR resonance before operation
        self._apply_entangled_resonance()
        
        # Make a copy of current amplitudes
        old_amplitudes = self.amplitudes.copy()
        
        # Calculate HyperMorphic 1/√2
        sqrt2_inv = self.hyper_core.divide(
            1.0, 
            math.sqrt(2), 
            dimensional_context=self.dimensional_context
        )
        
        # Apply Hadamard to second qubit
        self.amplitudes['ee'] = self.hyper_core.multiply(
            sqrt2_inv,
            self.hyper_core.add(
                old_amplitudes['ee'], 
                old_amplitudes['e1'],
                dimensional_context=self.dimensional_context
            ),
            dimensional_context=self.dimensional_context
        )
        
        self.amplitudes['e1'] = self.hyper_core.multiply(
            sqrt2_inv,
            self.hyper_core.subtract(
                old_amplitudes['ee'], 
                old_amplitudes['e1'],
                dimensional_context=self.dimensional_context
            ),
            dimensional_context=self.dimensional_context
        )
        
        self.amplitudes['1e'] = self.hyper_core.multiply(
            sqrt2_inv,
            self.hyper_core.add(
                old_amplitudes['1e'], 
                old_amplitudes['11'],
                dimensional_context=self.dimensional_context
            ),
            dimensional_context=self.dimensional_context
        )
        
        self.amplitudes['11'] = self.hyper_core.multiply(
            sqrt2_inv,
            self.hyper_core.subtract(
                old_amplitudes['1e'], 
                old_amplitudes['11'],
                dimensional_context=self.dimensional_context
            ),
            dimensional_context=self.dimensional_context
        )
        
        # Apply NCRSR resonance after operation
        self._apply_entangled_resonance()
        
        # Save current state to history
        self.state_history.appendleft(self.amplitudes.copy())
        
        return self
    
    def evolve(self, morph_rate=0.1):
        """
        Evolve the entangled state through HyperMorphic space.
        
        Args:
            morph_rate: Rate of evolution (0.0 to 1.0)
            
        Returns:
            Self (modified in place)
        """
        # Apply NCRSR resonance before evolution
        self._apply_entangled_resonance()
        
        # First evolve the hyper core
        self.hyper_core.evolve(morph_rate)
        
        # Get evolution parameters with AmorphousPi
        pi = self.amorphous_pi.calculate(dimension=self.dimensional_context)
        theta = morph_rate * pi / 4
        
        # Generate random phase factors for each amplitude
        morphing_factors = {
            k: cmath.exp(complex(0, theta * self._rng.uniform(-1, 1))) 
            for k in self.amplitudes
        }
        
        # Apply morphing with controlled evolution
        cos_theta = math.cos(theta)
        sin_theta = math.sin(theta)
        
        # Create mixed state through smooth evolution
        new_amplitudes = {}
        keys = list(self.amplitudes.keys())
        
        for i, k in enumerate(keys):
            # Find opposite state to mix with
            opposite_idx = (i + 2) % 4  # Cycle through states
            opposite_k = keys[opposite_idx]
            
            # Apply smooth morphing
            new_amplitudes[k] = (
                cos_theta * self.amplitudes[k] * morphing_factors[k] + 
                sin_theta * self.amplitudes[opposite_k] * complex(0, 1)
            )
        
        # Update amplitudes
        self.amplitudes = new_amplitudes
        
        # Apply normalization
        self._normalize()
        
        # Apply NCRSR resonance after evolution
        self._apply_entangled_resonance()
        
        # Save current state to history
        self.state_history.appendleft(self.amplitudes.copy())
        
        # Record evolution
        self.evolution_history.append({
            'timestamp': time.time(),
            'morph_rate': morph_rate,
            'dimensional_context': self.dimensional_context
        })
        
        return self
    
    def calculate_entanglement(self):
        """
        Calculate entanglement metrics for the state.
        
        Returns:
            Dictionary with entanglement metrics:
                - concurrence: Measure of entanglement (0=separable, 1=maximally entangled)
                - bell_state_fidelity: Fidelity with closest Bell state
                - entropy: Von Neumann entropy of reduced density matrix
        """
        # Construct density matrix for the entangled state
        rho = np.zeros((4, 4), dtype=complex)
        
        # Map states to indices
        state_indices = {
            'ee': 0,
            'e1': 1,
            '1e': 2,
            '11': 3
        }
        
        # Fill density matrix
        for k1, idx1 in state_indices.items():
            for k2, idx2 in state_indices.items():
                rho[idx1, idx2] = self.amplitudes[k1] * self.amplitudes[k2].conjugate()
        
        # Calculate reduced density matrix for first qubit
        rho_1 = np.zeros((2, 2), dtype=complex)
        rho_1[0, 0] = rho[0, 0] + rho[1, 1]  # |ϵᵩ⟩⟨ϵᵩ|
        rho_1[0, 1] = rho[0, 2] + rho[1, 3]  # |ϵᵩ⟩⟨1|
        rho_1[1, 0] = rho[2, 0] + rho[3, 1]  # |1⟩⟨ϵᵩ|
        rho_1[1, 1] = rho[2, 2] + rho[3, 3]  # |1⟩⟨1|
        
        # Calculate eigenvalues of reduced density matrix
        eigenvalues = np.linalg.eigvalsh(rho_1)
        
        # Calculate von Neumann entropy
        entropy = 0
        for ev in eigenvalues:
            if ev > 1e-10:  # Avoid log(0)
                entropy -= ev * math.log2(ev)
        
        # Calculate concurrence (measure of entanglement)
        # For a pure state, concurrence = 2*sqrt(det(rho_1))
        concurrence = 2 * math.sqrt(max(0, np.linalg.det(rho_1).real))
        
        # Calculate fidelity with the closest Bell state
        bell_states = [
            # |Φ+⟩ = 1/√2 (|00⟩ + |11⟩)
            {'ee': 1/math.sqrt(2), 'e1': 0, '1e': 0, '11': 1/math.sqrt(2)},
            # |Φ-⟩ = 1/√2 (|00⟩ - |11⟩)
            {'ee': 1/math.sqrt(2), 'e1': 0, '1e': 0, '11': -1/math.sqrt(2)},
            # |Ψ+⟩ = 1/√2 (|01⟩ + |10⟩)
            {'ee': 0, 'e1': 1/math.sqrt(2), '1e': 1/math.sqrt(2), '11': 0},
            # |Ψ-⟩ = 1/√2 (|01⟩ - |10⟩)
            {'ee': 0, 'e1': 1/math.sqrt(2), '1e': -1/math.sqrt(2), '11': 0}
        ]
        
        max_fidelity = 0
        closest_bell_state = 0
        
        for i, bell in enumerate(bell_states):
            # Calculate fidelity with this Bell state
            fidelity = abs(sum(bell[k].conjugate() * self.amplitudes[k] for k in self.amplitudes))**2
            
            if fidelity > max_fidelity:
                max_fidelity = fidelity
                closest_bell_state = i
        
        return {
            'concurrence': concurrence,
            'entropy': entropy,
            'bell_state_fidelity': max_fidelity,
            'closest_bell_state': closest_bell_state
        }
    
    def __str__(self):
        """String representation showing current state"""
        # Calculate amplitudes for display
        amp_strs = {}
        for k, v in self.amplitudes.items():
            amp_strs[k] = f"{v.real:.4f} + {v.imag:.4f}i"
        
        # Add emoji based on entanglement level
        ent_metrics = self.calculate_entanglement()
        
        if ent_metrics['concurrence'] < 0.3:
            ent_emoji = "🔅"  # Low entanglement
        elif ent_metrics['concurrence'] < 0.7:
            ent_emoji = "🔆"  # Medium entanglement
        else:
            ent_emoji = "✨"  # High entanglement
            
        sass_emoji = "💅" if self.sass_correlation > 0.5 else "✨"
            
        return (f"HyperEntangled{ent_emoji}{sass_emoji} ["
                f"ee={amp_strs['ee']}, e1={amp_strs['e1']}, "
                f"1e={amp_strs['1e']}, 11={amp_strs['11']}, "
                f"concurrence={ent_metrics['concurrence']:.2f}]")


# ============================================================================
# ⊹⊱ QUANTUM CIRCUITS WITH HYPERQUBIT NCRSR SYSTEMS ⊰⊹
# ============================================================================

class HyperQuantumGate:
    """
    Base class for quantum gates in the HyperQubit framework.
    
    All quantum gates in the HyperQubit framework are implemented as
    classes derived from this base class, with apply() methods that
    operate on HyperQubits.
    """
    def __init__(self, name):
        """Initialize the gate with a name"""
        self.name = name
        self.evolution_factor = 0.0  # Tracks gate evolution over time
    
    def apply(self, qubit):
        """
        Apply the gate to a HyperQubit.
        
        Args:
            qubit: The HyperQubit to which the gate is applied
            
        Returns:
            The resulting HyperQubit after gate application
        """
        raise NotImplementedError("Gate application must be implemented by subclasses")
    
    def evolve(self, rate=0.05):
        """
        Evolve the gate parameters to create a slightly modified gate.
        
        This is used to model gate drift over time and allows for
        adaptive gate calibration.
        
        Args:
            rate: Evolution rate
            
        Returns:
            Self (modified in place)
        """
        self.evolution_factor += rate
        # Specific implementation in subclasses
        return self
        
    def __str__(self):
        """String representation of the gate"""
        return f"HyperQuantumGate({self.name})"


class HadamardGate(HyperQuantumGate):
    """
    Hadamard gate implementation for HyperQubits with NCRSR protection.
    
    The Hadamard gate creates equal superpositions with phase differences.
    """
    def __init__(self, phase_offset=0.0):
        """
        Initialize a Hadamard gate with optional phase offset.
        
        Args:
            phase_offset: Additional phase to apply (defaults to 0)
        """
        super().__init__("H")
        self.phase_offset = phase_offset
    
    def apply(self, qubit):
        """
        Apply the Hadamard gate to a HyperQubit.
        
        Args:
            qubit: The HyperQubit to apply the gate to
            
        Returns:
            The resulting HyperQubit
        """
        if isinstance(qubit, HyperQubit):
            # Apply Hadamard operation
            result = qubit.hadamard()
            
            # Apply additional phase if needed
            if abs(self.phase_offset) > 1e-10:
                result = result.phase(self.phase_offset)
                
            return result
        else:
            raise TypeError("HadamardGate requires a HyperQubit")
    
    def evolve(self, rate=0.05):
        """
        Evolve the Hadamard gate by adjusting its phase offset.
        
        Args:
            rate: Evolution rate
            
        Returns:
            Self (modified in place)
        """
        super().evolve(rate)
        
        # Apply small oscillation to phase offset
        self.phase_offset += rate * math.sin(self.evolution_factor * math.pi)
        
        return self
    
    def __str__(self):
        """String representation of the Hadamard gate"""
        if abs(self.phase_offset) > 1e-10:
            return f"H(φ={self.phase_offset:.4f})"
        else:
            return "H"


class PauliXGate(HyperQuantumGate):
    """
    Pauli-X gate (NOT gate) implementation for HyperQubits with NCRSR protection.
    
    The Pauli-X gate flips |ϵᵩ⟩ to |1⟩ and vice versa.
    """
    def __init__(self):
        """Initialize a Pauli-X gate"""
        super().__init__("X")
    
    def apply(self, qubit):
        """
        Apply the Pauli-X gate to a HyperQubit.
        
        Args:
            qubit: The HyperQubit to apply the gate to
            
        Returns:
            The resulting HyperQubit
        """
        if isinstance(qubit, HyperQubit):
            return qubit.pauli_x()
        else:
            raise TypeError("PauliXGate requires a HyperQubit")
    
    def __str__(self):
        """String representation of the Pauli-X gate"""
        return "X"


class PauliZGate(HyperQuantumGate):
    """
    Pauli-Z gate implementation for HyperQubits with NCRSR protection.
    
    The Pauli-Z gate applies a phase flip to the |1⟩ component.
    """
    def __init__(self):
        """Initialize a Pauli-Z gate"""
        super().__init__("Z")
    
    def apply(self, qubit):
        """
        Apply the Pauli-Z gate to a HyperQubit.
        
        Args:
            qubit: The HyperQubit to apply the gate to
            
        Returns:
            The resulting HyperQubit
        """
        if isinstance(qubit, HyperQubit):
            return qubit.pauli_z()
        else:
            raise TypeError("PauliZGate requires a HyperQubit")
    
    def __str__(self):
        """String representation of the Pauli-Z gate"""
        return "Z"


class PhaseGate(HyperQuantumGate):
    """
    Phase gate implementation for HyperQubits with NCRSR protection.
    
    The Phase gate applies a relative phase between |ϵᵩ⟩ and |1⟩.
    """
    def __init__(self, phi):
        """
        Initialize a Phase gate with specified phase.
        
        Args:
            phi: Phase angle to apply
        """
        super().__init__("P")
        self.phi = phi
    
    def apply(self, qubit):
        """
        Apply the Phase gate to a HyperQubit.
        
        Args:
            qubit: The HyperQubit to apply the gate to
            
        Returns:
            The resulting HyperQubit
        """
        if isinstance(qubit, HyperQubit):
            return qubit.phase(self.phi)
        else:
            raise TypeError("PhaseGate requires a HyperQubit")
    
    def evolve(self, rate=0.05):
        """
        Evolve the Phase gate by adjusting its phase parameter.
        
        Args:
            rate: Evolution rate
            
        Returns:
            Self (modified in place)
        """
        super().evolve(rate)
        
        # Apply small drift to phase parameter
        self.phi += rate * math.sin(self.evolution_factor * math.pi * 2)
        
        # Keep phase within reasonable bounds
        self.phi %= (2 * math.pi)
        
        return self
    
    def __str__(self):
        """String representation of the Phase gate"""
        return f"P(φ={self.phi:.4f})"


class SassGate(HyperQuantumGate):
    """
    Sass gate implementation for HyperQubits with NCRSR protection.
    
    The Sass gate is unique to the HyperQubit framework and applies
    a specialized transformation that enhances the resonance properties
    of the quantum state. It is particularly effective at boosting sass
    and NCRSR protection. 💅✨
    """
    def __init__(self, theta=None):
        """
        Initialize a Sass gate with specified angle.
        
        Args:
            theta: Sass angle to apply (None for adaptive)
        """
        super().__init__("S💅")
        self.theta = theta
    
    def apply(self, qubit):
        """
        Apply the Sass gate to a HyperQubit.
        
        Args:
            qubit: The HyperQubit to apply the gate to
            
        Returns:
            The resulting HyperQubit with enhanced sass and resonance
        """
        if isinstance(qubit, HyperQubit):
            return qubit.apply_sass_operator(self.theta)
        else:
            raise TypeError("SassGate requires a HyperQubit 💅")
    
    def evolve(self, rate=0.05):
        """
        Evolve the Sass gate by adjusting its parameters.
        
        Args:
            rate: Evolution rate
            
        Returns:
            Self (modified in place)
        """
        super().evolve(rate)
        
        # Only evolve if we have a fixed theta
        if self.theta is not None:
            # Apply oscillating evolution
            self.theta += rate * math.sin(self.evolution_factor * math.pi * 3)
            
            # Keep theta within reasonable bounds
            self.theta %= (2 * math.pi)
        
        return self
    
    def __str__(self):
        """String representation of the Sass gate"""
        if self.theta is not None:
            return f"S💅(θ={self.theta:.4f})"
        else:
            return "S💅"


class HyperQuantumCircuit:
    """
    Quantum circuit implementation for the HyperQubit framework with NCRSR.
    
    A quantum circuit consists of a sequence of quantum gates applied to
    one or more HyperQubits, with optional measurements and entanglement.
    
    The HyperQuantumCircuit supports:
    - Single-qubit gates (Hadamard, Pauli-X, Pauli-Z, Phase, Sass)
    - Two-qubit gates (CNOT, CZ)
    - Measurement operations
    - NCRSR protection mechanisms
    - Circuit evolution and adaptation
    """
    def __init__(self, num_qubits: int, params: Optional[HyperParameters] = None):
        """
        Initialize a quantum circuit with specified number of qubits.
        
        Args:
            num_qubits: Number of qubits in the circuit
            params: Global parameters for the HyperMorphic framework
        """
        self.num_qubits = num_qubits
        self.params = params or HyperParameters()
        
        # Initialize with shared components for consistent math
        self.amorphous_pi = AmorphousPi(seed=hash("HyperQuantumCircuit"))
        self.hyper_core = HyperMorphicCore(
            dimensions=12,
            amorphous_pi=self.amorphous_pi,
            seed=hash("HyperQuantumCircuit"),
            params=self.params
        )
        
        # Create initial qubits
        self.qubits = [
            HyperQubit(
                hyper_core=self.hyper_core,
                amorphous_pi=self.amorphous_pi,
                dimensional_context=i+1,
                params=self.params
            )
            for i in range(num_qubits)
        ]
        
        # Track entangled pairs
        self.entangled_pairs = {}
        
        # Circuit operations
        self.operations = []
        
        # Measurement results
        self.measurements = {}
        
        # Noise model
        self.noise_model = {
            'depolarizing': 0.0,
            'phase_drift': 0.0,
            'amplitude_damping': 0.0
        }
        
        # Track circuit evolution
        self.circuit_evolution = 0.0
        
        # Circuit visualization data (for displaying circuit diagrams)
        self.visualization_data = {
            'width': 0,
            'height': num_qubits,
            'operations': []
        }
    
    def apply_gate(self, gate: HyperQuantumGate, qubit_idx: int) -> 'HyperQuantumCircuit':
        """
        Apply a quantum gate to a specific qubit.
        
        Args:
            gate: The gate to apply
            qubit_idx: Index of the qubit to apply the gate to
            
        Returns:
            Self (for method chaining)
        """
        # Check if qubit is part of an entangled pair
        entangled_with = None
        for (q1, q2), entangled in self.entangled_pairs.items():
            if qubit_idx == q1:
                entangled_with = q2
                break
            elif qubit_idx == q2:
                entangled_with = q1
                break
        
        if entangled_with is not None:
            # Apply gate to entangled state
            pair_key = tuple(sorted([qubit_idx, entangled_with]))
            entangled_state = self.entangled_pairs[pair_key]
            
            if qubit_idx == pair_key[0]:
                # Apply to first qubit in pair
                entangled_state.hadamard1() if gate.name == "H" else (
                    None  # Implement other gates as needed
                )
            else:
                # Apply to second qubit in pair
                entangled_state.hadamard2() if gate.name == "H" else (
                    None  # Implement other gates as needed
                )
        else:
            # Apply gate to individual qubit
            self.qubits[qubit_idx] = gate.apply(self.qubits[qubit_idx])
        
        # Record operation
        self.operations.append({
            'type': 'gate',
            'gate': gate.name,
            'qubit': qubit_idx
        })
        
        # Update visualization data
        self.visualization_data['width'] += 1
        self.visualization_data['operations'].append({
            'type': 'gate',
            'gate': str(gate),
            'qubit': qubit_idx,
            'position': self.visualization_data['width'] - 1
        })
        
        # Apply noise if enabled
        self._apply_noise(qubit_idx)
        
        return self
    
    def hadamard(self, qubit_idx: int) -> 'HyperQuantumCircuit':
        """
        Apply a Hadamard gate to a specific qubit.
        
        Args:
            qubit_idx: Index of the qubit to apply the gate to
            
        Returns:
            Self (for method chaining)
        """
        return self.apply_gate(HadamardGate(), qubit_idx)
    
    def pauli_x(self, qubit_idx: int) -> 'HyperQuantumCircuit':
        """
        Apply a Pauli-X gate to a specific qubit.
        
        Args:
            qubit_idx: Index of the qubit to apply the gate to
            
        Returns:
            Self (for method chaining)
        """
        return self.apply_gate(PauliXGate(), qubit_idx)
    
    def pauli_z(self, qubit_idx: int) -> 'HyperQuantumCircuit':
        """
        Apply a Pauli-Z gate to a specific qubit.
        
        Args:
            qubit_idx: Index of the qubit to apply the gate to
            
        Returns:
            Self (for method chaining)
        """
        return self.apply_gate(PauliZGate(), qubit_idx)
    
    def phase(self, qubit_idx: int, phi: float) -> 'HyperQuantumCircuit':
        """
        Apply a Phase gate to a specific qubit.
        
        Args:
            qubit_idx: Index of the qubit to apply the gate to
            phi: Phase angle to apply
            
        Returns:
            Self (for method chaining)
        """
        return self.apply_gate(PhaseGate(phi), qubit_idx)
    
    def sass(self, qubit_idx: int, theta: float = None) -> 'HyperQuantumCircuit':
        """
        Apply a Sass gate to a specific qubit to enhance resonance.
        
        Args:
            qubit_idx: Index of the qubit to apply the gate to
            theta: Optional sass angle (None for adaptive)
            
        Returns:
            Self (for method chaining)
        """
        return self.apply_gate(SassGate(theta), qubit_idx)
    
    def cnot(self, control: int, target: int) -> 'HyperQuantumCircuit':
        """
        Apply a CNOT gate between two qubits.
        
        Args:
            control: Index of the control qubit
            target: Index of the target qubit
            
        Returns:
            Self (for method chaining)
        """
        # First entangle qubits if not already entangled
        pair_key = tuple(sorted([control, target]))
        if pair_key not in self.entangled_pairs:
            self._entangle(control, target)
        
        # Apply CNOT to entangled state
        entangled_state = self.entangled_pairs[pair_key]
        entangled_state.apply_cnot(control_is_first=(control == pair_key[0]))
        
        # Record operation
        self.operations.append({
            'type': 'cnot',
            'control': control,
            'target': target
        })
        
        # Update visualization data
        self.visualization_data['width'] += 1
        self.visualization_data['operations'].append({
            'type': 'cnot',
            'control': control,
            'target': target,
            'position': self.visualization_data['width'] - 1
        })
        
        # Apply noise if enabled
        self._apply_noise(control)
        self._apply_noise(target)
        
        return self
    
    def cz(self, qubit1: int, qubit2: int) -> 'HyperQuantumCircuit':
        """
        Apply a CZ gate between two qubits.
        
        Args:
            qubit1: Index of the first qubit
            qubit2: Index of the second qubit
            
        Returns:
            Self (for method chaining)
        """
        # First entangle qubits if not already entangled
        pair_key = tuple(sorted([qubit1, qubit2]))
        if pair_key not in self.entangled_pairs:
            self._entangle(qubit1, qubit2)
        
        # Apply CZ to entangled state
        entangled_state = self.entangled_pairs[pair_key]
        entangled_state.apply_cz()
        
        # Record operation
        self.operations.append({
            'type': 'cz',
            'qubit1': qubit1,
            'qubit2': qubit2
        })
        
        # Update visualization data
        self.visualization_data['width'] += 1
        self.visualization_data['operations'].append({
            'type': 'cz',
            'qubit1': qubit1,
            'qubit2': qubit2,
            'position': self.visualization_data['width'] - 1
        })
        
        # Apply noise if enabled
        self._apply_noise(qubit1)
        self._apply_noise(qubit2)
        
        return self
    
    def _entangle(self, qubit1: int, qubit2: int) -> None:
        """
        Create entanglement between two qubits.
        
        Args:
            qubit1: Index of the first qubit
            qubit2: Index of the second qubit
        """
        # Create entangled state
        entangled_state = self.qubits[qubit1].entangle_with(self.qubits[qubit2])
        
        # Store the entangled state
        pair_key = tuple(sorted([qubit1, qubit2]))
        self.entangled_pairs[pair_key] = entangled_state
        
        # Record operation
        self.operations.append({
            'type': 'entangle',
            'qubit1': qubit1,
            'qubit2': qubit2
        })
    
    def measure(self, qubit_idx: int, name: str = None) -> 'HyperQuantumCircuit':
        """
        Measure a specific qubit with NCRSR protection.
        
        Args:
            qubit_idx: Index of the qubit to measure
            name: Optional name for the measurement
            
        Returns:
            Self (for method chaining)
        """
        measurement_name = name or f"m{qubit_idx}"
        
        # Check if qubit is part of an entangled pair
        entangled_with = None
        for (q1, q2), entangled in self.entangled_pairs.items():
            if qubit_idx == q1:
                entangled_with = q2
                break
            elif qubit_idx == q2:
                entangled_with = q1
                break
        
        if entangled_with is not None:
            # Measure entangled qubit
            pair_key = tuple(sorted([qubit_idx, entangled_with]))
            entangled_state = self.entangled_pairs[pair_key]
            
            if qubit_idx == pair_key[0]:
                # Measure first qubit in pair
                outcome, prob, qubit_state = entangled_state.measure_qubit1()
                # Update second qubit state
                self.qubits[entangled_with] = qubit_state
            else:
                # Measure second qubit in pair
                outcome, prob, qubit_state = entangled_state.measure_qubit2()
                # Update first qubit state
                self.qubits[pair_key[0]] = qubit_state
            
            # Remove entanglement (partially - NCRSR maintains weak connection)
            self.entangled_pairs[pair_key] = None
        else:
            # Measure individual qubit
            outcome, prob = self.qubits[qubit_idx].measure()
        
        # Store measurement result
        self.measurements[measurement_name] = {
            'qubit': qubit_idx,
            'outcome': outcome,
            'probability': prob
        }
        
        # Record operation
        self.operations.append({
            'type': 'measure',
            'qubit': qubit_idx,
            'name': measurement_name,
            'outcome': outcome
        })
        
        # Update visualization data
        self.visualization_data['width'] += 1
        self.visualization_data['operations'].append({
            'type': 'measure',
            'qubit': qubit_idx,
            'name': measurement_name,
            'outcome': outcome,
            'position': self.visualization_data['width'] - 1
        })
        
        return self
    
    def measure_all(self) -> Dict[str, Dict]:
        """
        Measure all qubits in the circuit with NCRSR protection.
        
        Returns:
            Dictionary of measurement results
        """
        # First measure all entangled pairs
        for (q1, q2), entangled in list(self.entangled_pairs.items()):
            if entangled is not None:
                # Measure both qubits in the entangled pair
                outcome, prob = entangled.measure_both()
                
                # Store measurement results
                self.measurements[f"m{q1}"] = {
                    'qubit': q1,
                    'outcome': outcome[0],
                    'probability': prob
                }
                
                self.measurements[f"m{q2}"] = {
                    'qubit': q2,
                    'outcome': outcome[1],
                    'probability': prob
                }
                
                # Record operations
                self.operations.append({
                    'type': 'measure',
                    'qubit': q1,
                    'name': f"m{q1}",
                    'outcome': outcome[0]
                })
                
                self.operations.append({
                    'type': 'measure',
                    'qubit': q2,
                    'name': f"m{q2}",
                    'outcome': outcome[1]
                })
                
                # Update visualization data
                self.visualization_data['width'] += 1
                self.visualization_data['operations'].append({
                    'type': 'measure_pair',
                    'qubit1': q1,
                    'qubit2': q2,
                    'outcome1': outcome[0],
                    'outcome2': outcome[1],
                    'position': self.visualization_data['width'] - 1
                })
                
                # Remove entanglement
                self.entangled_pairs[q1, q2] = None
        
        # Then measure remaining individual qubits
        for i, qubit in enumerate(self.qubits):
            # Skip if already measured as part of an entangled pair
            if f"m{i}" in self.measurements:
                continue
            
            # Measure individual qubit
            outcome, prob = qubit.measure()
            
            # Store measurement result
            self.measurements[f"m{i}"] = {
                'qubit': i,
                'outcome': outcome,
                'probability': prob
            }
            
            # Record operation
            self.operations.append({
                'type': 'measure',
                'qubit': i,
                'name': f"m{i}",
                'outcome': outcome
            })
            
            # Update visualization data
            self.visualization_data['width'] += 1
            self.visualization_data['operations'].append({
                'type': 'measure',
                'qubit': i,
                'name': f"m{i}",
                'outcome': outcome,
                'position': self.visualization_data['width'] - 1
            })
        
        return self.measurements
    
    def _apply_noise(self, qubit_idx: int) -> None:
        """
        Apply noise to a specific qubit based on the noise model.
        
        Args:
            qubit_idx: Index of the qubit to apply noise to
        """
        # Check if qubit is part of an entangled pair
        entangled_with = None
        for (q1, q2), entangled in self.entangled_pairs.items():
            if qubit_idx == q1:
                entangled_with = q2
                break
            elif qubit_idx == q2:
                entangled_with = q1
                break
        
        if entangled_with is not None:
            # Apply noise to entangled state
            # (entangled states have inherent NCRSR protection)
            # For now, we don't need to implement this
            pass
        else:
            # Apply depolarizing noise
            if self.noise_model['depolarizing'] > 0:
                self.qubits[qubit_idx].add_depolarizing_noise(
                    self.noise_model['depolarizing']
                )
            
            # Apply coherent noise (phase and amplitude errors)
            if self.noise_model['phase_drift'] > 0 or self.noise_model['amplitude_damping'] > 0:
                self.qubits[qubit_idx].add_coherent_noise(
                    self.noise_model['phase_drift'],
                    self.noise_model['amplitude_damping']
                )
    
    def set_noise_model(self, depolarizing=0.0, phase_drift=0.0, amplitude_damping=0.0):
        """
        Set the noise model for the quantum circuit.
        
        Args:
            depolarizing: Probability of depolarizing error
            phase_drift: Phase drift angle (radians)
            amplitude_damping: Amplitude damping rate
            
        Returns:
            Self (for method chaining)
        """
        self.noise_model = {
            'depolarizing': depolarizing,
            'phase_drift': phase_drift,
            'amplitude_damping': amplitude_damping
        }
        
        return self
    
    def reset(self) -> 'HyperQuantumCircuit':
        """
        Reset the circuit to its initial state.
        
        Returns:
            Self (for method chaining)
        """
        # Create fresh qubits
        self.qubits = [
            HyperQubit(
                hyper_core=self.hyper_core,
                amorphous_pi=self.amorphous_pi,
                dimensional_context=i+1,
                params=self.params
            )
            for i in range(self.num_qubits)
        ]
        
        # Clear entangled pairs
        self.entangled_pairs = {}
        
        # Clear operations
        self.operations = []
        
        # Clear measurements
        self.measurements = {}
        
        # Reset visualization data
        self.visualization_data = {
            'width': 0,
            'height': self.num_qubits,
            'operations': []
        }
        
        return self
    
    def evolve(self, rate=0.1) -> 'HyperQuantumCircuit':
        """
        Evolve the quantum circuit by evolving its components.
        
        This simulates the natural drift that occurs in quantum systems
        over time, allowing for adaptive recalibration strategies.
        
        Args:
            rate: Evolution rate
            
        Returns:
            Self (for method chaining)
        """
        # Track circuit evolution
        self.circuit_evolution += rate
        
        # Evolve the HyperMorphic core
        self.hyper_core.evolve(rate * 0.5)
        
        # Evolve the AmorphousPi system
        self.amorphous_pi.evolve(steps=1)
        
        # Evolve each qubit
        for i, qubit in enumerate(self.qubits):
            self.qubits[i] = qubit.evolve(rate * 0.3)
        
        # Evolve entangled states
        for pair, entangled in self.entangled_pairs.items():
            if entangled is not None:
                entangled.evolve(rate * 0.3)
        
        return self
    
    def draw(self) -> str:
        """
        Generate a simple ASCII circuit diagram.
        
        Returns:
            String representation of the circuit diagram
        """
        width = max(1, self.visualization_data['width'])
        height = self.num_qubits
        
        # Create empty grid
        grid = [[' ' for _ in range(width * 4 + 1)] for _ in range(height * 2 + 1)]
        
        # Draw qubit lines
        for q in range(height):
            y = q * 2 + 1
            for x in range(width * 4 + 1):
                grid[y][x] = '─'
        
        # Draw operations
        for op in self.visualization_data['operations']:
            x = op['position'] * 4 + 2
            
            if op['type'] == 'gate':
                y = op['qubit'] * 2 + 1
                
                # Replace segment with gate symbol
                if op['gate'] == "H":
                    grid[y][x-1:x+2] = ['┤', 'H', '├']
                elif op['gate'] == "X":
                    grid[y][x-1:x+2] = ['┤', 'X', '├']
                elif op['gate'] == "Z":
                    grid[y][x-1:x+2] = ['┤', 'Z', '├']
                elif op['gate'].startswith("P"):
                    grid[y][x-1:x+2] = ['┤', 'P', '├']
                elif op['gate'].startswith("S"):
                    grid[y][x-1:x+2] = ['┤', 'S', '├']
            
            elif op['type'] == 'cnot':
                control_y = op['control'] * 2 + 1
                target_y = op['target'] * 2 + 1
                
                # Draw vertical line
                start_y = min(control_y, target_y)
                end_y = max(control_y, target_y)
                for y in range(start_y, end_y + 1):
                    if y == control_y:
                        grid[y][x] = '●'  # Control point
                    elif y == target_y:
                        grid[y][x] = '⊕'  # Target point
                    else:
                        grid[y][x] = '│'  # Connecting line
            
            elif op['type'] == 'cz':
                q1_y = op['qubit1'] * 2 + 1
                q2_y = op['qubit2'] * 2 + 1
                
                # Draw vertical line
                start_y = min(q1_y, q2_y)
                end_y = max(q1_y, q2_y)
                for y in range(start_y, end_y + 1):
                    if y == q1_y or y == q2_y:
                        grid[y][x] = '●'  # Both points are controls
                    else:
                        grid[y][x] = '│'  # Connecting line
            
            elif op['type'] == 'measure':
                y = op['qubit'] * 2 + 1
                
                # Draw measurement symbol
                grid[y][x-1:x+2] = ['┤', 'M', '├']
                
                # Add outcome if available
                if 'outcome' in op:
                    outcome = 'ε' if op['outcome'] == 'epsilon' else op['outcome']
                    if x + 3 < width * 4 + 1:
                        grid[y][x+2] = outcome
            
            elif op['type'] == 'measure_pair':
                q1_y = op['qubit1'] * 2 + 1
                q2_y = op['qubit2'] * 2 + 1
                
                # Draw measurement symbols
                grid[q1_y][x-1:x+2] = ['┤', 'M', '├']
                grid[q2_y][x-1:x+2] = ['┤', 'M', '├']
                
                # Add outcomes if available
                if 'outcome1' in op:
                    outcome = 'ε' if op['outcome1'] == 'epsilon' else op['outcome1']
                    if x + 3 < width * 4 + 1:
                        grid[q1_y][x+2] = outcome
                
                if 'outcome2' in op:
                    outcome = 'ε' if op['outcome2'] == 'epsilon' else op['outcome2']
                    if x + 3 < width * 4 + 1:
                        grid[q2_y][x+2] = outcome
        
        # Add qubit labels
        for q in range(height):
            y = q * 2 + 1
            if y < len(grid) and len(grid[y]) > 0:
                grid[y][0] = f'q{q}'
        
        # Convert grid to string
        diagram = '\n'.join(''.join(row) for row in grid)
        
        return diagram
    
    def __str__(self):
        """String representation of the quantum circuit"""
        return f"HyperQuantumCircuit(qubits={self.num_qubits}, operations={len(self.operations)})"


# ============================================================================
# ⊹⊱ EXAMPLE IMPLEMENTATIONS AND USAGE ⊰⊹
# ============================================================================

def teleport_demo():
    """
    Quantum teleportation demo using the HyperQubit-NCRSR framework.
    
    Demonstrates how to create an entangled state, teleport a quantum state,
    and perform error correction using the NCRSR features.
    """
    print("🌌✨ HyperQubit-NCRSR Quantum Teleportation Demo ✨🌌")
    
    # Create shared parameters for consistent math
    params = HyperParameters()
    
    # Create a HyperMorphic core and AmorphousPi system
    amorphous_pi = AmorphousPi(seed=42)
    hyper_core = HyperMorphicCore(
        dimensions=12,
        amorphous_pi=amorphous_pi,
        seed=42,
        params=params
    )
    
    # Create a 3-qubit circuit for teleportation
    circuit = HyperQuantumCircuit(3, params=params)
    
    # Create a custom state on the first qubit
    # (this is the state we want to teleport)
    theta = math.pi / 4  # 45-degree state
    circuit.qubits[0] = HyperQubit(
        alpha=complex(math.cos(theta/2), 0),
        beta=complex(math.sin(theta/2), 0),
        hyper_core=hyper_core,
        amorphous_pi=amorphous_pi,
        params=params
    )
    
    print(f"Initial State to Teleport: {circuit.qubits[0]}")
    
    # Prepare entanglement between qubits 1 and 2
    circuit.hadamard(1)
    circuit.cnot(1, 2)
    
    # Verify successful entanglement
    entangled_metrics = circuit.entangled_pairs[1, 2].calculate_entanglement()
    print(f"Entanglement Metrics: {entangled_metrics}")
    
    # Apply teleportation protocol
    circuit.cnot(0, 1)
    circuit.hadamard(0)
    
    # Measure control qubits
    circuit.measure(0, "m0")
    circuit.measure(1, "m1")
    
    # Print measurement results
    print(f"Measurement Results: {circuit.measurements}")
    
    # Apply corrections to target qubit based on measurement outcomes
    if circuit.measurements["m1"]["outcome"] == '1':
        circuit.pauli_x(2)
    if circuit.measurements["m0"]["outcome"] == '1':
        circuit.pauli_z(2)
    
    # Verify teleported state
    fidelity = circuit.qubits[2].fidelity([math.cos(theta/2), math.sin(theta/2)])
    print(f"Teleported State: {circuit.qubits[2]}")
    print(f"Teleportation Fidelity: {fidelity:.6f}")
    
    # Demonstrate NCRSR error protection by adding noise
    print("\n🛡️ Demonstrating NCRSR Error Protection:")
    
    # Compare standard qubit vs HyperQubit with noise
    std_qubit = StandardQubit([math.cos(theta/2), math.sin(theta/2)])
    hyper_qubit = HyperQubit(
        alpha=complex(math.cos(theta/2), 0),
        beta=complex(math.sin(theta/2), 0),
        hyper_core=hyper_core,
        amorphous_pi=amorphous_pi,
        params=params
    )
    
    # Apply Sass to enhance NCRSR protection
    hyper_qubit = hyper_qubit.apply_sass_operator()
    
    noise_levels = [0.05, 0.1, 0.2, 0.3]
    
    print("Noise Level | Standard Qubit Fidelity | HyperQubit NCRSR Fidelity")
    print("---------------------------------------------------------------")
    
    for noise in noise_levels:
        # Apply noise to standard qubit
        noisy_std = StandardQubit([math.cos(theta/2), math.sin(theta/2)])
        noisy_std.add_depolarizing_noise(noise)
        std_fidelity = noisy_std.fidelity([math.cos(theta/2), math.sin(theta/2)])
        
        # Apply noise to HyperQubit
        noisy_hyper = hyper_qubit.add_depolarizing_noise(noise)
        hyper_fidelity = noisy_hyper.fidelity([math.cos(theta/2), math.sin(theta/2)])
        
        print(f"  {noise:.2f}    |       {std_fidelity:.6f}       |       {hyper_fidelity:.6f}")
    
    print("\n🌌✨ End of HyperQubit-NCRSR Quantum Teleportation Demo ✨🌌")
    
    return circuit


def bell_state_demo():
    """
    Bell state preparation and measurement demo using the HyperQubit-NCRSR framework.
    
    Demonstrates how to create Bell states, measure them, and analyze entanglement
    properties with NCRSR protection.
    """
    print("🌌✨ HyperQubit-NCRSR Bell State Demo ✨🌌")
    
    # Create a 2-qubit circuit
    circuit = HyperQuantumCircuit(2)
    
    # Prepare a Bell state (|00⟩ + |11⟩) / √2
    circuit.hadamard(0)
    circuit.cnot(0, 1)
    
    # Print circuit diagram
    print("Circuit Diagram:")
    print(circuit.draw())
    print()
    
    # Check entanglement metrics
    entangled_metrics = circuit.entangled_pairs[0, 1].calculate_entanglement()
    print(f"Entanglement Metrics: {entangled_metrics}")
    
    # Demonstrate NCRSR by adding noise
    print("\n🛡️ Adding Noise to Entangled State...")
    circuit.set_noise_model(depolarizing=0.1, phase_drift=0.05)
    
    # Apply a gate (which will also apply noise)
    circuit.phase(0, math.pi/4)
    
    # Check entanglement metrics after noise
    entangled_metrics = circuit.entangled_pairs[0, 1].calculate_entanglement()
    print(f"Entanglement Metrics After Noise: {entangled_metrics}")
    
    # Measure in computational basis
    print("\n📊 Measuring Bell State...")
    results = circuit.measure_all()
    
    # Print measurement results
    print(f"Measurement Results: {results}")
    
    # Calculate correlation
    outcome0 = results["m0"]["outcome"]
    outcome1 = results["m1"]["outcome"]
    
    if outcome0 == outcome1:
        print("✅ Results show perfect correlation as expected for Bell state |Φ+⟩")
    else:
        print("⚠️ Results show anti-correlation (possibly due to noise or phase rotation)")
    
    print("\n🌌✨ End of HyperQubit-NCRSR Bell State Demo ✨🌌")
    
    return circuit


def error_correction_demo():
    """
    Quantum error correction demo using the HyperQubit-NCRSR framework.
    
    Demonstrates how NCRSR provides enhanced protection against errors
    compared to traditional quantum error correction codes.
    """
    print("🌌✨ HyperQubit-NCRSR Error Correction Demo ✨🌌")
    
    # Create shared parameters for consistent math
    params = HyperParameters()
    
    # Create a HyperMorphic core and AmorphousPi system
    amorphous_pi = AmorphousPi(seed=42)
    hyper_core = HyperMorphicCore(
        dimensions=12,
        amorphous_pi=amorphous_pi,
        seed=42,
        params=params
    )
    
    # Create a 3-qubit circuit for 3-qubit bit flip code
    circuit = HyperQuantumCircuit(3, params=params)
    
    # Initialize first qubit in superposition state
    circuit.hadamard(0)
    
    # Encode using CNOT gates (3-qubit bit flip code)
    circuit.cnot(0, 1)
    circuit.cnot(0, 2)
    
    # Check initial state
    print("Initial Encoded State:")
    print(f"Qubit 0: {circuit.qubits[0]}")
    print(f"Qubit 1: {circuit.qubits[1]}")
    print(f"Qubit 2: {circuit.qubits[2]}")
    
    # Prepare identical state for comparison
    init_state = circuit.qubits[0].alpha, circuit.qubits[0].beta
    
    # Apply error to middle qubit (bit flip)
    print("\n🛡️ Applying Bit Flip Error to Qubit 1...")
    circuit.pauli_x(1)
    
    # Apply NCRSR protection (Sass operator enhances resonance)
    print("🛡️ Applying NCRSR Protection (Sass Operator)...")
    circuit.sass(0)
    circuit.sass(1)
    circuit.sass(2)
    
    # Apply error correction
    print("🛡️ Applying Error Correction...")
    
    # Use majority vote to detect error (simplified)
    # In a real implementation, we would use syndrome measurements
    # Here we're using the internal state for demonstration
    
    # Apply correction based on syndrome
    circuit.cnot(0, 1)  # Detect error in qubit 1
    circuit.cnot(0, 2)  # Detect error in qubit 2
    
    # Measure syndrome qubits
    circuit.measure(1, "syndrome1")
    circuit.measure(2, "syndrome2")
    
    print(f"Syndrome Measurements: {circuit.measurements}")
    
    # Apply correction based on syndrome
    if circuit.measurements["syndrome1"]["outcome"] == '1':
        print("Detected error in qubit 1, applying correction...")
        circuit.pauli_x(1)
    
    if circuit.measurements["syndrome2"]["outcome"] == '1':
        print("Detected error in qubit 2, applying correction...")
        circuit.pauli_x(2)
    
    # Check final state
    print("\nFinal Corrected State:")
    print(f"Qubit 0: {circuit.qubits[0]}")
    
    # Calculate fidelity with initial state
    fidelity = circuit.qubits[0].fidelity(init_state)
    print(f"Fidelity with Initial State: {fidelity:.6f}")
    
    # Compare with standard quantum error correction
    print("\n🔍 Comparison with Standard Quantum Error Correction:")
    
    # Traditional 3-qubit code success probability (theoretical)
    std_success_prob = 1 - 3*(0.1**2) + 2*(0.1**3)  # For 10% error rate
    
    print(f"Theoretical Success Probability (Standard Code): {std_success_prob:.6f}")
    print(f"Actual Success Probability (HyperQubit NCRSR): {fidelity:.6f}")
    
    if fidelity > std_success_prob:
        print("✅ HyperQubit NCRSR outperforms traditional quantum error correction!")
    else:
        print("⚠️ Traditional quantum error correction performed better in this case.")
    
    print("\n🌌✨ End of HyperQubit-NCRSR Error Correction Demo ✨🌌")
    
    return circuit


if __name__ == "__main__":
    # Set up general parameters
    params = HyperParameters(
        dimensionality=12,         # Base dimensionality of the system
        sass_factor=0.42,          # Cosmological sassiness constant 💅
        zero_threshold=1e-10,      # Threshold for zero-free mathematics
        recursion_depth=3,         # Depth for recursive calculations
        phase_conjugation=True,    # Enable tachyonic phase conjugation
        timeline_branches=7,       # Number of quantum timeline branches
        resonance_frequency=7.83,  # Base Schumann resonance frequency
        manifold_flux=0.1,         # Rate of topological manifold evolution
        entropy_reversal=0.05,     # Rate of entropy reversal in calculations
        reality_anchor=1.0         # Connection strength to base reality
    )
    
    # Run the Bell state demo
    bell_circuit = bell_state_demo()
    print("\n" + "="*70 + "\n")
    
    # Run the teleportation demo
    teleport_circuit = teleport_demo()
    print("\n" + "="*70 + "\n")
    
    # Run the error correction demo
    error_circuit = error_correction_demo()
